-- ServerStorage/Modules/DataSavingHandler/DataHandling.lua
-- FIXED: Only look at items that ACTUALLY have conveyor parts

-- Services
local RepStorage = game:GetService("ReplicatedStorage")
-- Modules
local MainLib = require(RepStorage.Modules.MainLib)
-- DataHandling
local DataHandling = {}

-- Cache base speed so we only look it up once
local CACHED_BASE_SPEED = nil

local function LOAD_ITEM_BASICS(ITEM)
	-- Add layer information when loading items
	if ITEM:FindFirstChild("ItemStats") then
		local itemStats = require(ITEM.ItemStats)

		-- Add PlacementLayer if it doesn't exist
		if not ITEM:FindFirstChild("PlacementLayer") then
			local layerValue = Instance.new("IntValue", ITEM)
			layerValue.Name = "PlacementLayer"

			if type(itemStats.PlacementLayer) == "table" then
				layerValue.Value = itemStats.PlacementLayer[1]
				local layersString = Instance.new("StringValue", ITEM)
				layersString.Name = "PlacementLayers"
				layersString.Value = table.concat(itemStats.PlacementLayer, ",")
			else
				layerValue.Value = itemStats.PlacementLayer or 1
			end
		end
	end

	for I, DESCENDANT in pairs(ITEM:GetDescendants()) do
		if DESCENDANT:IsA("Script") then
			DESCENDANT.Disabled = DESCENDANT:FindFirstChild("ForceDisabled")
		end
		if I%50 == 0 then
			wait()
		end
	end
end

-- Check if a part is a conveyor by its name
local function isConveyorPart(part)
	return part.Name == "Conv" or 
		part.Name == "ConvMerge" or 
		part.Name == "ConvSlope" or 
		part.Name == "ConvSlopeMerge"
end

-- Get base conveyor speed by finding an ACTUAL conveyor part
local function getBaseConveyorSpeed()
	-- Return cached value if we have it
	if CACHED_BASE_SPEED then
		return CACHED_BASE_SPEED
	end

	print("Looking for base conveyor speed by checking actual conveyor parts...")

	-- Look through ALL items to find one that CONTAINS a conveyor part
	for _, repItem in pairs(RepStorage.Items:GetChildren()) do
		-- Check if this item has any conveyor parts
		for _, descendant in pairs(repItem:GetDescendants()) do
			if descendant:IsA("BasePart") and isConveyorPart(descendant) then
				-- Found a conveyor part! Check its ConvVelo
				local convVelo = descendant:FindFirstChild("ConvVelo")
				if convVelo and math.abs(convVelo.Value) > 0 then
					CACHED_BASE_SPEED = math.abs(convVelo.Value)
					print("✓ Found base conveyor speed:", CACHED_BASE_SPEED, "from", descendant.Name, "in item:", repItem.Name)
					return CACHED_BASE_SPEED
				end
			end
		end
	end

	-- Last resort fallback
	CACHED_BASE_SPEED = 7
	warn("⚠ Could not find base conveyor speed, using default:", CACHED_BASE_SPEED)
	return CACHED_BASE_SPEED
end

-- Helper function to apply conveyor upgrades directly
local function ApplyConveyorUpgradeToItem(item, upgradeLevel)
	if upgradeLevel == 0 then return 0 end

	local baseSpeed = getBaseConveyorSpeed()
	local conveyorsUpdated = 0

	for _, descendant in pairs(item:GetDescendants()) do
		-- Check if this is ANY conveyor part
		if descendant:IsA("BasePart") and isConveyorPart(descendant) then
			local convVelo = descendant:FindFirstChild("ConvVelo")
			if convVelo then
				-- Get the CURRENT value to check direction
				local currentValue = convVelo.Value
				local isReversed = currentValue < 0

				-- Check if this is a sloped conveyor (gets 0.5x upgrade instead of 1x)
				local isSloped = (descendant.Name == "ConvSlope" or descendant.Name == "ConvSlopeMerge")
				local speedBoost = isSloped and (upgradeLevel * 0.5) or upgradeLevel

				-- Calculate new speed
				local newSpeed = baseSpeed + speedBoost

				-- Apply with correct direction
				if isReversed then
					convVelo.Value = -newSpeed
				else
					convVelo.Value = newSpeed
				end

				conveyorsUpdated = conveyorsUpdated + 1
			end
		end
	end

	return conveyorsUpdated
end

function DataHandling.LOAD_PLOT(Plr, PLOT_DATA)
	Plr:WaitForChild("SetPlot")
	local PLR_PLOT = Plr.SetPlot.Value

	-- Get player's conveyor upgrade level ONCE at the start
	local conveyorUpgradeLevel = 0
	if _G["global_data"] and _G["global_data"][Plr.Name] and _G["global_data"][Plr.Name]["Upgrades"] then
		conveyorUpgradeLevel = _G["global_data"][Plr.Name]["Upgrades"]["ConveyorSpeed"] or 0
	end

	if conveyorUpgradeLevel > 0 then
		local baseSpeed = getBaseConveyorSpeed()
		print("=== LOADING PLOT WITH CONVEYOR UPGRADES ===")
		print("Player:", Plr.Name)
		print("Base Speed:", baseSpeed)
		print("Upgrade Level:", conveyorUpgradeLevel)
		print("Expected Final Speed:", baseSpeed + conveyorUpgradeLevel)
	end

	local totalConveyorsUpdated = 0

	for I, item_data in pairs(PLOT_DATA) do
		if item_data["item_pos"] then
			local ITEM_MODEL = MainLib.ITEM_FROM_ID(item_data["ITEM_ID"])
			if ITEM_MODEL.PrimaryPart ~= ITEM_MODEL.Hitbox then
				ITEM_MODEL.PrimaryPart = ITEM_MODEL.Hitbox
			end
			ITEM_MODEL = ITEM_MODEL:Clone()
			local item_pos = PLR_PLOT.BasePlot.CFrame * CFrame.new(unpack(item_data["item_pos"]))
			ITEM_MODEL:SetPrimaryPartCFrame(item_pos)

			-- Apply conveyor reversal if saved (only for non-merge conveyors)
			if item_data["CONVEYOR_REVERSED"] then
				ITEM_MODEL:SetAttribute("ConveyorReversed", true)

				for _, descendant in pairs(ITEM_MODEL:GetDescendants()) do
					-- Only reverse Conv and ConvSlope (NOT merge conveyors)
					if descendant:IsA("BasePart") and (descendant.Name == "Conv" or descendant.Name == "ConvSlope") then
						if descendant:GetAttribute("NoFlip") then
							continue
						end

						local convVelo = descendant:FindFirstChild("ConvVelo")
						if convVelo then
							convVelo.Value = -convVelo.Value
						end

						local beam = descendant:FindFirstChildOfClass("Beam")
						if beam then
							beam.TextureSpeed = -beam.TextureSpeed
						end
					end
				end
			end

			-- Restore sorter configuration if saved
			if item_data["SORT_CONFIG"] then
				local sortConfig = ITEM_MODEL:FindFirstChild("SortConfig")
				if not sortConfig then
					sortConfig = Instance.new("Folder")
					sortConfig.Name = "SortConfig"
					sortConfig.Parent = ITEM_MODEL
				end

				for oreName, direction in pairs(item_data["SORT_CONFIG"]) do
					local config = Instance.new("StringValue")
					config.Name = oreName
					config.Value = direction
					config.Parent = sortConfig
				end
			end

			-- Restore assembly machine configuration if saved
			if item_data["ASSEMBLY_CONFIG"] then
				local assemblyConfig = ITEM_MODEL:FindFirstChild("AssemblyConfig")
				if not assemblyConfig then
					assemblyConfig = Instance.new("StringValue")
					assemblyConfig.Name = "AssemblyConfig"
					assemblyConfig.Parent = ITEM_MODEL
				end
				assemblyConfig.Value = item_data["ASSEMBLY_CONFIG"]
			end

			-- *** APPLY CONVEYOR UPGRADES TO ALL CONVEYOR TYPES BEFORE PARENTING ***
			if conveyorUpgradeLevel > 0 then
				local updated = ApplyConveyorUpgradeToItem(ITEM_MODEL, conveyorUpgradeLevel)
				totalConveyorsUpdated = totalConveyorsUpdated + updated
			end

			-- Parent to plot (scripts will start running after this)
			ITEM_MODEL.Parent = PLR_PLOT.PlacedItems
			LOAD_ITEM_BASICS(ITEM_MODEL)
		else
			_G["global_data"][Plr.Name]["Items"][tostring(item_data["ITEM_ID"])].Amount += 1
		end
	end

	if conveyorUpgradeLevel > 0 then
		print("Total conveyors updated:", totalConveyorsUpdated)
		print("=== FINISHED LOADING PLOT ===")
	end
end

function DataHandling.UNLOAD_PLOT(Plr)
	if Plr:FindFirstChild("SetPlot") then
		local PLR_PLOT = Plr.SetPlot.Value
		local PLOT_DATA = {}
		for I, ITEM in pairs(PLR_PLOT.PlacedItems:GetChildren()) do
			if ITEM:FindFirstChild("Hitbox") and ITEM:FindFirstChild("ItemStats") then

				-- Skip hotspot items
				if ITEM:GetAttribute("HotspotMiner") == true then
					continue
				end

				if ITEM:GetAttribute("HotspotFurnace") == true then
					continue
				end

				local ITEM_INFO = require(ITEM.ItemStats)
				local itemData = {
					["ITEM_ID"] = ITEM_INFO.ItemId,
					["item_pos"] = {(PLR_PLOT.BasePlot.CFrame:Inverse() * ITEM.PrimaryPart.CFrame):components()}
				}

				-- Save conveyor reversal state
				if ITEM:GetAttribute("ConveyorReversed") then
					itemData["CONVEYOR_REVERSED"] = true
				end

				-- Save sorter configuration
				local sortConfig = ITEM:FindFirstChild("SortConfig")
				if sortConfig then
					local configData = {}
					for _, config in pairs(sortConfig:GetChildren()) do
						if config:IsA("StringValue") then
							configData[config.Name] = config.Value
						end
					end
					if next(configData) then
						itemData["SORT_CONFIG"] = configData
					end
				end

				-- Save assembly machine configuration
				local assemblyConfig = ITEM:FindFirstChild("AssemblyConfig")
				if assemblyConfig and assemblyConfig:IsA("StringValue") then
					itemData["ASSEMBLY_CONFIG"] = assemblyConfig.Value
				end

				PLOT_DATA[#PLOT_DATA+1] = itemData
			end
		end
		return PLOT_DATA
	end
end

return DataHandling
