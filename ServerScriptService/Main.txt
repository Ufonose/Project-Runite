-- ServerScriptService/Main.txt

-- Services
local RepStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Plrs = game:GetService("Players")
-- Modules
local MAIN_LIB = require(RepStorage.Modules.MainLib)
-- Variables
-- Arrays
local DEBOUNCE = {}

-- Define minimum quantities that must remain for each item (by item name)
local MINIMUM_ITEM_QUANTITIES = {
	["Standard Conveyor"] = 18,
	["Corner Conveyor"] = 4,
	-- Add more items as needed
}

warn("Zonix_Official's Sandbox Tycoon Kit 2.0 Main [SERVER] loading...")

function PLACE_ITEM(Plr, PLACED_ITEMS, ITEMS)
	if Plr and PLACED_ITEMS and ITEMS then
		local ITEM_FAILED = false
		for I, ITEM in pairs(ITEMS) do
			local ITEM_REP = RepStorage.Items:FindFirstChild(ITEM["ITEM_NAME"])
			local ITEM_INFO = require(ITEM_REP.ItemStats)
			-- FIXED: Changed item_info to ITEM_INFO and added tostring()
			if _G["global_data"][Plr.Name]["Items"][tostring(ITEM_INFO.ItemId)]["Amount"] > 0 then
				local REAL_ITEM = ITEM_REP:Clone()
				REAL_ITEM:SetPrimaryPartCFrame(ITEM["ITEM_LOCATION"])

				-- Store the placement layer on the item
				local layerValue = Instance.new("IntValue", REAL_ITEM)
				layerValue.Name = "PlacementLayer"
				if type(ITEM_INFO.PlacementLayer) == "table" then
					layerValue.Value = ITEM_INFO.PlacementLayer[1]
					local layersString = Instance.new("StringValue", REAL_ITEM)
					layersString.Name = "PlacementLayers"
					layersString.Value = table.concat(ITEM_INFO.PlacementLayer, ",")
				else
					layerValue.Value = ITEM_INFO.PlacementLayer or 1
				end

				-- IMPORTANT: Reverse ConvVelo and Beam BEFORE enabling scripts!
				if ITEM["CONVEYOR_REVERSED"] then
					REAL_ITEM:SetAttribute("ConveyorReversed", true)
					print("=== REVERSING CONVEYOR ===")
					print("Item:", REAL_ITEM.Name)

					for _, descendant in pairs(REAL_ITEM:GetDescendants()) do
						if descendant:IsA("BasePart") and (descendant.Name == "Conv" or descendant.Name == "ConvSlope") then
							if descendant:GetAttribute("NoFlip") then
								print("Skipping", descendant:GetFullName(), "- NoFlip attribute set")
								continue
							end
							if descendant.Name == "ConvMerge" then
								print("Skipping ConvMerge - cannot flip direction")
								continue
							end

							local convVelo = descendant:FindFirstChild("ConvVelo")
							if convVelo then
								print("Found ConvVelo:", convVelo.Value)
								convVelo.Value = -convVelo.Value
								print("Reversed to:", convVelo.Value)
							else
								warn("ConvVelo not found on Conv part!")
							end

							local beam = descendant:FindFirstChildOfClass("Beam")
							if beam then
								print("Found Beam, TextureSpeed:", beam.TextureSpeed)
								beam.TextureSpeed = -beam.TextureSpeed
								print("Reversed Beam TextureSpeed to:", beam.TextureSpeed)
							end
						end
					end
					print("=== REVERSAL COMPLETE ===")
				end

				-- â­ Apply Conveyor Speed Upgrade
				if ITEM_INFO.ConveyorSpeed and ITEM_INFO.ConveyorSpeed > 0 then
					-- Get the player's conveyor speed upgrade
					local speedBonus = 0
					if _G.GetUpgradeMultiplier then
						speedBonus = _G.GetUpgradeMultiplier(Plr, "ConveyorSpeed")
					end

					-- Apply speed bonus to all Conv, ConvMerge, and ConvSlope parts
					for _, descendant in pairs(REAL_ITEM:GetDescendants()) do
						if descendant:IsA("BasePart") and (descendant.Name == "Conv" or descendant.Name == "ConvMerge" or descendant.Name == "ConvSlope") then
							local convVelo = descendant:FindFirstChild("ConvVelo")
							if convVelo then
								local baseSpeed = math.abs(convVelo.Value)  -- Get absolute value (in case reversed)
								local isNegative = convVelo.Value < 0
								local newSpeed = baseSpeed + speedBonus
								convVelo.Value = isNegative and -newSpeed or newSpeed
								print("Applied conveyor speed upgrade:", descendant.Name, "Base:", baseSpeed, "Bonus:", speedBonus, "Final:", convVelo.Value)
							end
						end
					end
				end

				REAL_ITEM.Parent = PLACED_ITEMS

				-- FIXED: Changed item_info to ITEM_INFO and added tostring()
				_G["global_data"][Plr.Name]["Items"][tostring(ITEM_INFO.ItemId)]["Amount"] -= 1

				spawn(function()
					for E, DESCENDANT in pairs(REAL_ITEM:GetDescendants()) do
						if DESCENDANT:IsA("Script") then
							DESCENDANT.Disabled = DESCENDANT:FindFirstChild("ForceDisabled")
						end
						if E%50 == 0 then
							wait()
						end
					end					

					RepStorage.Events.InventoryUpdate:FireClient(Plr)
				end)
			else
				ITEM_FAILED = true
			end
		end
		return not ITEM_FAILED
	end
	return false
end


function GET_INVENTORY(Plr, INVENTORY_TYPE)
	local INV_GETTING = Plr		-- Make this be the Plot Owner if possible but if not be the Plr
	return _G["global_data"][INV_GETTING.Name][INVENTORY_TYPE]
end

function BUY_ITEM(Plr, ITEM_ID, AMOUNT)
	local CASH = ServerStorage.ServerLockedPlayerInfo.PlayerCash:FindFirstChild(Plr.Name)
	if CASH then
		local CANT_BUY_TYPES = {"special", "cantbuy"}
		local AMOUNT = AMOUNT or 1
		local ITEM_ID = ITEM_ID
		local COST_VAL = 0
		if type(ITEM_ID) ~= "table" then
			ITEM_ID = {ITEM_ID}
		end
		local BOUGHT_ITEMS = {}
		for I, REAL_ID in pairs(ITEM_ID) do
			local REAL_ITEM = MAIN_LIB.ITEM_FROM_ID(REAL_ID)
			local ITEM_INFO = require(REAL_ITEM.ItemStats)
			if table.find(CANT_BUY_TYPES, ITEM_INFO.ItemType) == nil then	-- string.lower(ITEM_INFO.ItemType) == "special" or string.lower(ITEM_INFO.CostType) == "cantbuy" then
				if CASH.Value >= math.floor(ITEM_INFO.Cost*AMOUNT) then
					COST_VAL += math.floor(ITEM_INFO.Cost*AMOUNT)
					BOUGHT_ITEMS[#BOUGHT_ITEMS+1] = REAL_ID
				end
			end
		end
		if #BOUGHT_ITEMS == #ITEM_ID then
			CASH.Value -= COST_VAL
			for I, ITEM_ID in pairs(BOUGHT_ITEMS) do
				ServerStorage.Events.ItemGive:Invoke(Plr, ITEM_ID, AMOUNT)
			end
			return true
		end
	end
	return false
end

function SELL_ITEM(Plr, ITEMS)
	local CASH = ServerStorage.ServerLockedPlayerInfo.PlayerCash:FindFirstChild(Plr.Name)
	if CASH then
		local CANT_SELL_TYPES = {"special", "cantbuy"}
		local ITEM_ID = ITEMS
		if type(ITEM_ID) ~= "table" then
			ITEM_ID = {ITEM_ID}
		end

		-- Count items being sold by name
		local itemsBeingSold = {}
		for I, REAL_ID in pairs(ITEM_ID) do
			local ITEM_INFO = require(REAL_ID.ItemStats)
			local itemName = MAIN_LIB.ITEM_FROM_ID(ITEM_INFO.ItemId).Name
			itemsBeingSold[itemName] = (itemsBeingSold[itemName] or 0) + 1
		end

		-- Count TOTAL items (placed on plot + in inventory)
		local PLR_PLOT = Plr.SetPlot.Value
		local PLACED_ITEMS = PLR_PLOT.PlacedItems
		local totalItemCounts = {}

		-- Count placed items
		for _, placedItem in pairs(PLACED_ITEMS:GetChildren()) do
			local itemName = placedItem.Name
			totalItemCounts[itemName] = (totalItemCounts[itemName] or 0) + 1
		end

		-- Count inventory items
		for itemIdStr, itemData in pairs(_G["global_data"][Plr.Name]["Items"]) do
			local itemId = tonumber(itemIdStr)
			if itemId then
				local itemModel = MAIN_LIB.ITEM_FROM_ID(itemId)
				if itemModel then
					local itemName = itemModel.Name
					totalItemCounts[itemName] = (totalItemCounts[itemName] or 0) + itemData.Amount
				end
			end
		end

		-- Check if selling would go below minimum
		for itemName, sellCount in pairs(itemsBeingSold) do
			local minimumRequired = MINIMUM_ITEM_QUANTITIES[itemName]
			if minimumRequired then
				local totalCount = totalItemCounts[itemName] or 0
				local remainingAfterSale = totalCount - sellCount

				if remainingAfterSale < minimumRequired then
					warn(string.format(
						"Cannot sell %s: would leave %d but need %d minimum",
						itemName,
						remainingAfterSale,
						minimumRequired
						))
					RepStorage.Events.MessageClient:FireClient(
						Plr,
						"screen",
						{["message"] = string.format("You need at least %d %s", minimumRequired, itemName)}
					)
					return false
				end
			end
		end

		local SOLD_ITEMS = {}
		for I, REAL_ID in pairs(ITEM_ID) do
			local ITEM_INFO = require(REAL_ID.ItemStats)
			if table.find(CANT_SELL_TYPES, ITEM_INFO.ItemType) == nil then
				SOLD_ITEMS[#SOLD_ITEMS+1] = REAL_ID
			end
		end

		if #SOLD_ITEMS == #ITEM_ID then
			local TOTAL_VAL = 0
			for I, REAL_ID in pairs(SOLD_ITEMS) do
				local ITEM_INFO = require(REAL_ID.ItemStats)
				local ITEM_VAL = math.floor(ITEM_INFO.Cost*0.3)
				TOTAL_VAL += ITEM_VAL
				-- FIXED: Added tostring() for item ID
				_G["global_data"][Plr.Name]["Items"][tostring(ITEM_INFO.ItemId)]["Amount"] -= 1
			end
			CASH.Value += TOTAL_VAL
			RepStorage.Events.InventoryUpdate:FireClient(Plr)
			return true
		end
	end
	return false
end

function UPDATE_STORT(Plr)
	local PLR_PLOT = Plr.SetPlot.Value
	local INV_TYPE = Plr.InvSort.Value
	if PLR_PLOT and INV_TYPE then
		-- Refresh inventory!
		RepStorage.Events.InventoryUpdate:FireClient(Plr)
	end
end

function WITHDRAW_ITEMS(Plr, ITEMS)
	if DEBOUNCE[Plr] == true then
		RepStorage.Events.MessageClient:FireClient(Plr, "screen", {["message"] = "Wait before withdrawing again!"})
		return false
	end
	DEBOUNCE[Plr] = true
	if ITEMS then
		for I, ITEM in pairs(ITEMS) do
			-- Check if this is a hotspot-only miner (don't allow withdrawal)
			if ITEM:GetAttribute("HotspotMiner") == true then
				warn("Cannot withdraw hotspot miner!")
				RepStorage.Events.MessageClient:FireClient(Plr, "screen", {["message"] = "Hotspot miners cannot be moved!"})
				return false
			end

			if ITEM:GetAttribute("HotspotFurnace") == true then
				warn("Cannot withdraw hotspot furnace!")
				RepStorage.Events.MessageClient:FireClient(Plr, "screen", {["message"] = "The central furnace cannot be moved!"})
				return false
			end

			local ITEM_INFO = require(ITEM.ItemStats)
			-- FIXED: Changed item_info to ITEM_INFO and added tostring()
			_G["global_data"][Plr.Name]["Items"][tostring(ITEM_INFO.ItemId)]["Amount"] += 1
			ITEM:Destroy()
		end
		RepStorage.Events.InventoryUpdate:FireClient(Plr)
		DEBOUNCE[Plr] = false
		return true
	end
	DEBOUNCE[Plr] = false
	return false
end

function toggle_update(plr, toggle_name)
	local real_setting = plr.Settings:FindFirstChild(toggle_name)
	if real_setting ~= nil then
		real_setting.Value = not real_setting.Value
		return true
	end
	warn(toggle_name.." doesn't exist for "..plr.Name.." so it's either failed to load or not been implemented!")
	return false
end

-- Function/Event Responses
RepStorage.Events.GetInventoryType.OnServerInvoke = GET_INVENTORY
RepStorage.Events.WithdrawItems.OnServerInvoke = WITHDRAW_ITEMS
RepStorage.Events.UpdateStorting.OnServerInvoke = UPDATE_STORT
RepStorage.Events.UpdateToggle.OnServerInvoke = toggle_update
RepStorage.Events.PlaceItem.OnServerInvoke = PLACE_ITEM
RepStorage.Events.SellItem.OnServerInvoke = SELL_ITEM
RepStorage.Events.BuyItem.OnServerInvoke = BUY_ITEM

-- Server Locked Stuff
function ItemGive(Plr, ITEM_ID, AMOUNT)
	-- FIXED: Added tostring() for item ID
	if _G["global_data"][Plr.Name]["Items"][tostring(ITEM_ID)] then
		_G["global_data"][Plr.Name]["Items"][tostring(ITEM_ID)]["Amount"] += AMOUNT
		RepStorage.Events.MessageClient:FireClient(Plr, "screen", {["message"] = ""..AMOUNT.." "..MAIN_LIB.ITEM_FROM_ID(ITEM_ID).Name.."'s added to your Inventory"})
		RepStorage.Events.InventoryUpdate:FireClient(Plr)
		return true
	end
	return false
end

-- Server Locked Functions/Events
ServerStorage.Events.ItemGive.OnInvoke = ItemGive

warn("Zonix_Official's Sandbox Tycoon Kit 2.0 Main [SERVER] loaded!")
