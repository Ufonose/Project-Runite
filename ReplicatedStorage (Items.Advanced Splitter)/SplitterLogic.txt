local RepStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local ITEM_INFO = require(script.Parent.ItemStats)

local SPLITTER = script.Parent
local SPLIT_DETECTOR = SPLITTER:WaitForChild("SortDetector")

-- Simple alternating state (true = left, false = right)
local sendLeft = true

-- Detection settings - LOWERED to detect small objects
local DETECTION_HEIGHT = 4  -- Total height of detection box
local DETECTION_OFFSET = -1  -- Shift box DOWN to catch objects on surface

local trackedOres = {}

-- Helper to get ore info
local function getOreInfo(part)
	local ore = nil

	-- Check if part itself is ore
	if part:FindFirstChild("Cash") then
		ore = part
		-- Check if parent model is ore
	elseif part.Parent and part.Parent:IsA("Model") and part.Parent:FindFirstChild("Cash") then
		ore = part.Parent:FindFirstChildWhichIsA("BasePart")
	end

	return ore
end

-- Check if ore is on this splitter
local function isOreOnSplitter(orePart)
	local orePos = orePart.Position
	local detectorPos = SPLIT_DETECTOR.Position

	-- Check horizontal distance
	local horizontalDistance = (Vector2.new(orePos.X, orePos.Z) - Vector2.new(detectorPos.X, detectorPos.Z)).Magnitude
	local maxHorizontalDistance = math.max(SPLIT_DETECTOR.Size.X, SPLIT_DETECTOR.Size.Z) / 2

	if horizontalDistance > maxHorizontalDistance then
		return false
	end

	-- Check vertical distance
	local verticalDistance = math.abs(orePos.Y - detectorPos.Y)
	return verticalDistance <= (SPLIT_DETECTOR.Size.Y + DETECTION_HEIGHT) / 2
end

-- Calculate split velocity
local function getSplitVelocity(goLeft)
	local baseCFrame = SPLIT_DETECTOR.CFrame
	local speed = ITEM_INFO.SortSpeed or 20

	if goLeft then
		-- Rotate left by SortAngle degrees
		local angle = math.rad(ITEM_INFO.SortAngle or 45)
		return (baseCFrame * CFrame.Angles(0, angle, 0)).LookVector * speed
	else
		-- Rotate right by SortAngle degrees
		local angle = math.rad(-(ITEM_INFO.SortAngle or 45))
		return (baseCFrame * CFrame.Angles(0, angle, 0)).LookVector * speed
	end
end

-- Main detection loop
RunService.Heartbeat:Connect(function()
	-- Calculate detection region - LOWERED to catch small objects
	local detectorCFrame = SPLIT_DETECTOR.CFrame
	local detectorSize = SPLIT_DETECTOR.Size

	local detectionSize = Vector3.new(
		detectorSize.X,
		DETECTION_HEIGHT,
		detectorSize.Z
	)

	-- Shift detection box DOWN so bottom is BELOW the surface
	local detectionCFrame = detectorCFrame * CFrame.new(0, (DETECTION_HEIGHT/2) + DETECTION_OFFSET, 0)

	-- Get all parts in region
	local partsInRegion = workspace:GetPartBoundsInBox(detectionCFrame, detectionSize)

	-- Update tracked ores
	for ore, data in pairs(trackedOres) do
		-- Clean up if ore destroyed
		if not ore.Parent then
			trackedOres[ore] = nil
			-- Clean up if traveled too far or too much time
		elseif (ore.Position - data.startPosition).Magnitude > SPLIT_DETECTOR.Size.Z * 3 or (tick() - data.startTime) > 5 then
			trackedOres[ore] = nil
			-- Keep moving if still on splitter
		elseif isOreOnSplitter(ore) then
			local velocity = getSplitVelocity(data.goLeft)
			ore.AssemblyLinearVelocity = velocity
		else
			-- Ore left the splitter
			trackedOres[ore] = nil
		end
	end

	-- Check for NEW ores in region
	for _, part in pairs(partsInRegion) do
		local ore = getOreInfo(part)

		-- Only track if NEW ore and actually on splitter
		if ore and not trackedOres[ore] and isOreOnSplitter(ore) then
			-- TOGGLE happens ONLY when new ore is detected
			trackedOres[ore] = {
				goLeft = sendLeft,
				startTime = tick(),
				startPosition = ore.Position
			}

			-- Toggle for NEXT ore
			sendLeft = not sendLeft
		end
	end
end)

print("Splitter logic loaded with SMALL OBJECT DETECTION!")
