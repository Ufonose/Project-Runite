local module = {}

function module.SELECT_ITEM()
	warn("ItemSelection.SELECT_ITEM() HASN'T LOADED YET!")
end

function module.ITEM_DETECT()
	warn("ItemSelection.ITEM_DETECT() HASN'T LOADED YET!")
end

function module.LOAD(MODULE_INFO)
	-- Basic Needs
	local MODULES = MODULE_INFO["MODULES"]
	local SERVICES = MODULE_INFO["SERVICES"]
	-- Services
	local InputService = SERVICES["UserInputService"]
	local RepStorage = SERVICES["ReplicatedStorage"]
	local RunService = SERVICES["RunService"]
	local Plrs = SERVICES["Players"]
	-- Modules
	local ITEM_HOVER = MODULES["ItemHover"]
	local PLACEMENT = MODULES["Placement"]
	local MainLib = MODULES["MainLib"]
	local INPUT = MODULES["Input"]
	local ModernItemSelection = MODULES["ModernItemSelection"]
	local CASH_LIB = MODULES["CashLib"]  -- For number formatting
	local SoundManager = require(RepStorage.Modules.SoundManager)
	-- Plr Info
	local Plr = Plrs.LocalPlayer
	local Mouse = Plr:GetMouse()
	local PLR_PLOT = Plr.SetPlot.Value
	-- Variables
	-- Booleans
	local DB = true
	module.SELECTING_ITEMS = false
	-- Arrays
	local SELECTED_ITEMS = {}
	-- Integers
	module.SELECTED_COUNT = 0
	-- Objects
	local CURRENT_HOVER = nil
	local FIRST_SELECTED_ITEM = nil  -- Track first selected item for anchoring

	-- Create modern UI
	local modernUI = ModernItemSelection.CREATE_MODERN_SELECTION_UI(script.Parent.Parent)
	modernUI.Container.Visible = false

	-- Hide old ItemSelection GUI
	script.Parent.Parent.ItemSelection.Enabled = false
	script.Parent.Parent.ItemSelection.Adornee = nil

	-- Update menu position every frame when visible
	RunService.RenderStepped:Connect(function()
		if modernUI.Container.Visible and FIRST_SELECTED_ITEM then
			modernUI.UpdatePosition()
		end
	end)

	local function UPDATE_SELECTED_INFO()
		if module.SELECTED_COUNT == 1 then
			for I, ITEM_INFO in pairs(SELECTED_ITEMS) do
				modernUI.ItemName.Text = ITEM_INFO.Name
				local TIER_NAME, TIER_INFO = MainLib.GET_ITEM_TIER_INFO(ITEM_INFO.Name)
				modernUI.ItemTier.Text = TIER_NAME
				modernUI.ItemTier.TextColor3 = TIER_INFO["TIER_COLOR"]
				FIRST_SELECTED_ITEM = ITEM_INFO  -- Store for anchoring

				-- Get item stats and set prices
				if ITEM_INFO:FindFirstChild("ItemStats") then
					local itemStats = require(ITEM_INFO.ItemStats)
					local buyPrice = itemStats.Cost or 0
					local sellPrice = math.floor(buyPrice * 0.3)  -- Sell price is 30% of buy price

					-- Update price labels (includes button name in text)
					if modernUI.BuyPrice then
						modernUI.BuyPrice.Text = "Buy - $" .. CASH_LIB.SUFFIX_NUM(buyPrice)
					end
					if modernUI.SellPrice then
						modernUI.SellPrice.Text = "Sell - $" .. CASH_LIB.SUFFIX_NUM(sellPrice)
					end
				end
			end
		else
			modernUI.ItemName.Text = "Multi-Select"
			modernUI.ItemTier.TextColor3 = Color3.fromRGB(140, 140, 140)
			modernUI.ItemTier.Text = "Item Count: "..module.SELECTED_COUNT

			-- For multi-select, calculate total value
			local totalBuyPrice = 0
			local totalSellPrice = 0
			for I, ITEM_INFO in pairs(SELECTED_ITEMS) do
				if ITEM_INFO:FindFirstChild("ItemStats") then
					local itemStats = require(ITEM_INFO.ItemStats)
					local itemBuyPrice = itemStats.Cost or 0
					totalBuyPrice = totalBuyPrice + itemBuyPrice
					totalSellPrice = totalSellPrice + math.floor(itemBuyPrice * 0.3)  -- 30% of buy price
				end
				if I == 1 then
					FIRST_SELECTED_ITEM = ITEM_INFO
				end
			end

			-- Update price labels (includes button name in text)
			if modernUI.BuyPrice then
				modernUI.BuyPrice.Text = "Buy - " .. CASH_LIB.SUFFIX_NUM(totalBuyPrice)
			end
			if modernUI.SellPrice then
				modernUI.SellPrice.Text = "Sell - " .. CASH_LIB.SUFFIX_NUM(totalSellPrice)
			end
		end
	end

	function module.SELECT_ITEM(ITEM)
		module.SELECTING_ITEMS = true
		for I, ITEM in pairs(SELECTED_ITEMS) do
			ITEM:SetAttribute("SELECTED", true)
			if ITEM:FindFirstChild("Hitbox") then
				ITEM.Hitbox.Transparency = .7
			end
		end
		if SELECTED_ITEMS[ITEM] ~= ITEM then
			SELECTED_ITEMS[ITEM] = ITEM
			if ITEM:FindFirstChild("Hitbox") then
				ITEM.Hitbox.Transparency = .7
				module.SELECTED_COUNT += 1
			end
			UPDATE_SELECTED_INFO()
		end
		-- IMPORTANT: Hide tooltip and clear hover reference when selecting
		if ITEM_HOVER.ModernHover then
			ITEM_HOVER.ModernHover.Hide()
		end
		if script.Parent.Parent.ItemHover:FindFirstChild("HoveredItemRef") then
			script.Parent.Parent.ItemHover.HoveredItemRef.Value = nil
		end
	end

	function module.UNSELECT_ITEMS()
		for I, ITEM in pairs(SELECTED_ITEMS) do
			ITEM:SetAttribute("SELECTED", nil)
			if ITEM:FindFirstChild("Hitbox") then
				ITEM.Hitbox.Transparency = 1
			end
			SELECTED_ITEMS[ITEM] = nil
		end
		module.SELECTED_COUNT = 0
		SELECTED_ITEMS = {}
		FIRST_SELECTED_ITEM = nil
		ModernItemSelection.HIDE_MENU()
	end

	local function CLEAR_HOVER(ITEM)
		local ITEM = ITEM or nil
		local CURRENT_HOVER_BACKUP = CURRENT_HOVER
		if CURRENT_HOVER ~= ITEM then
			-- Hide modern hover UI
			if ITEM_HOVER.ModernHover then
				ITEM_HOVER.ModernHover.Hide()
			end

			-- Clear the item reference
			if script.Parent.Parent.ItemHover:FindFirstChild("HoveredItemRef") then
				script.Parent.Parent.ItemHover.HoveredItemRef.Value = nil
			end

			if CURRENT_HOVER_BACKUP ~= nil and not CURRENT_HOVER_BACKUP:GetAttribute("SELECTED") then
				if CURRENT_HOVER_BACKUP:FindFirstChild("Hitbox") then
					CURRENT_HOVER_BACKUP.Hitbox.Transparency = 1
				end
				if CURRENT_HOVER == CURRENT_HOVER_BACKUP then
					CURRENT_HOVER = nil
				end
			end
		end
	end

	local function HOVER_ITEM(ITEM)
		-- Clear hovering items
		if CURRENT_HOVER ~= nil then
			CLEAR_HOVER(ITEM)
		end
		if ITEM ~= nil and SELECTED_ITEMS[ITEM] ~= ITEM then
			-- Set the item to be a item that is being hovered
			if CURRENT_HOVER ~= ITEM then
				CURRENT_HOVER = ITEM
				if ITEM:FindFirstChild("Hitbox") then
					ITEM.Hitbox.Transparency = .85
				end
			end

			-- Only show tooltip if we're not in selection mode
			if not module.SELECTING_ITEMS and module.SELECTED_COUNT == 0 then
				-- Use modern hover UI
				if ITEM_HOVER.ModernHover then
					local TIER_NAME, TIER_INFO = MainLib.GET_ITEM_TIER_INFO(ITEM.Name)
					ITEM_HOVER.ModernHover.ItemTier.TextColor3 = TIER_INFO["TIER_COLOR"]
					ITEM_HOVER.ModernHover.ItemTier.Text = TIER_NAME

					-- Remove trailing numbers from the display name (e.g., "Gold Mine 1" â†’ "Gold Mine")
					local displayName = ITEM.Name:gsub("%s*%d+$", "")
					ITEM_HOVER.ModernHover.ItemName.Text = displayName

					-- Check if this is a hotspot miner with a drop table
					local isHotspotMiner = ITEM:GetAttribute("HotspotMiner") == true
					local showDropTable = false
					local dropTableText = ""

					if isHotspotMiner and ITEM:FindFirstChild("ItemStats") then
						local success, itemStats = pcall(function()
							return require(ITEM.ItemStats)
						end)

						if success and itemStats.DropTable and #itemStats.DropTable > 0 then
							showDropTable = true

							-- Define colors for different gems
							local colorMap = {
								["Diamond Gem"] = "#00FFFF",  -- Cyan
								["Ruby Gem"] = "#e20000",      -- Red
								["Emerald Gem"] = "#00FF00",   -- Green
								["Gold Ore"] = "#FFD700",      -- Gold
								["Iron Ore"] = "#a16f53",      
								["Copper Ore"] = "#a34827",     
								-- Add more ore/gem colors as needed
							}

							-- Build the drop table text with colored entries
							for i, drop in ipairs(itemStats.DropTable) do
								local dropName = drop.Name
								local dropChance = drop.Chance

								-- Get color for this drop type (default to white if not in map)
								local hexColor = colorMap[dropName] or "#FFFFFF"

								-- Format: "Name - X.X%"
								local line = string.format(
									'<font color="%s">%s - %.1f%%</font>',
									hexColor,
									dropName,
									dropChance
								)

								if i > 1 then
									dropTableText = dropTableText .. "\n"
								end
								dropTableText = dropTableText .. line
							end
						end
					end

					-- Show expanded or compact view based on whether we have drop data
					if showDropTable then
						ITEM_HOVER.ModernHover.ShowExpanded(dropTableText,true)
					else
						ITEM_HOVER.ModernHover.ShowCompact(true)
					end

					ITEM_HOVER.ModernHover.Show()
				end

				-- Store reference to the actual item object
				if not script.Parent.Parent.ItemHover:FindFirstChild("HoveredItemRef") then
					local objValue = Instance.new("ObjectValue")
					objValue.Name = "HoveredItemRef"
					objValue.Parent = script.Parent.Parent.ItemHover
				end
				script.Parent.Parent.ItemHover.HoveredItemRef.Value = ITEM

				ITEM_HOVER.UPDATE_HOVER()
			end
		end
	end

	local function FINALIZE_SELECTING()
		module.SELECTING_ITEMS = false
		if module.SELECTED_COUNT > 0 then
			UPDATE_SELECTED_INFO()
			ModernItemSelection.SHOW_MENU(FIRST_SELECTED_ITEM)
		end
	end

	-- This is the ITEM_DETECT function section that needs to replace the existing one
	-- Find the module.ITEM_DETECT() function in your ItemSelection script and replace it with this:

	-- Add this at the top of the module (after the variables section):
	-- Track which item is currently tapped for hover on mobile
	local mobileHoveredItem = nil
	local lastTapProcessed = false  -- Track if we already processed current tap

	-- Helper function for modern raycast detection (works on both PC and mobile)
	local function findItemAtPosition(screenPosition, isMobile)
		if not screenPosition then return nil end

		local adjustedPosition = screenPosition

		if isMobile then
			-- MOBILE FIX: Scale touch coordinates to match viewport
			-- Touch coordinates are in device pixels, but viewport might be scaled
			local camera = workspace.CurrentCamera
			local viewportSize = camera.ViewportSize

			-- Get the actual screen size (in device pixels)
			local screenSize = Vector2.new(
				screenPosition.X,
				screenPosition.Y
			)

			-- The touch Y coordinate needs to be adjusted
			-- Based on your debug: tap at Y=62 hits item that appears at Y=20-30
			-- This is roughly a 40 pixel offset downward
			-- Let's try adding an offset based on viewport height

			local yOffset = 40  -- Start with this offset (similar to PC's +36)

			adjustedPosition = Vector2.new(
				screenPosition.X,
				screenPosition.Y + yOffset
			)
		end

		-- Create ray from screen position
		local ray = workspace.CurrentCamera:ViewportPointToRay(adjustedPosition.X, adjustedPosition.Y)

		-- Setup raycast parameters - INCLUDE only placed items
		local raycastParams = RaycastParams.new()
		raycastParams.FilterDescendantsInstances = PLR_PLOT.PlacedItems:GetChildren()
		raycastParams.FilterType = Enum.RaycastFilterType.Include
		raycastParams.IgnoreWater = true

		-- Perform modern raycast
		local result = workspace:Raycast(ray.Origin, ray.Direction * 1000, raycastParams)

		if result and result.Instance and result.Instance.Parent:FindFirstChild("ItemStats") then
			return result.Instance
		end

		return nil
	end

	function module.ITEM_DETECT()
		if PLACEMENT.PLACING_ITEMS then		-- Big no no for item selection :)
			CLEAR_HOVER()
			mobileHoveredItem = nil
			return
		end
		if #script.Parent.Parent.Values.OpenedMenus:GetChildren() > 0 then		-- No item selection if a menu is open (Prevents bugs with the hovering of items.)
			CLEAR_HOVER()
			mobileHoveredItem = nil
			return
		end

		-- Determine raycast point based on input method
		local ITEM_CAST_POINT
		local shouldProcessTap = false  -- Only process NEW taps
		local ITEM_HOVERING = nil

		if Mouse and InputService.MouseEnabled then
			-- PC: Use mouse position with the existing offset
			ITEM_CAST_POINT = Vector2.new(Mouse.X, Mouse.Y + 36)
			ITEM_HOVERING = findItemAtPosition(ITEM_CAST_POINT, false)

		elseif INPUT.IS_MOBILE then
			-- MOBILE: Check if there's a NEW tap to process
			if INPUT.TAP_ACTIVE and not lastTapProcessed then
				-- NEW TAP! Process it only once
				shouldProcessTap = true
				lastTapProcessed = true

				-- Use tap position with mobile adjustment
				ITEM_HOVERING = findItemAtPosition(INPUT.TAP_POSITION, true)
			elseif not INPUT.TAP_ACTIVE then
				-- Tap ended - reset for next tap
				lastTapProcessed = false
			end

			-- Keep showing hover for previously tapped item (unless it's selected)
			if not shouldProcessTap and mobileHoveredItem and mobileHoveredItem.Parent then
				if not mobileHoveredItem:GetAttribute("SELECTED") then
					HOVER_ITEM(mobileHoveredItem)
				end
				return
			elseif not shouldProcessTap then
				-- Not tapping and no item to show - just return
				return
			end
		else
			-- Fallback for other input methods
			local CAM_SIZE = workspace.CurrentCamera.ViewportSize
			ITEM_CAST_POINT = Vector2.new(math.floor(CAM_SIZE.X/2),math.floor(CAM_SIZE.Y/3))
			ITEM_HOVERING = findItemAtPosition(ITEM_CAST_POINT, false)
		end

		if PLR_PLOT ~= nil then
			if ITEM_HOVERING and ITEM_HOVERING.Parent:FindFirstChild("ItemStats") then
				-- NEW: Add line-of-sight check to the found item
				local itemPosition = ITEM_HOVERING.Position
				local cameraPosition = workspace.CurrentCamera.CFrame.Position
				local directionToItem = (itemPosition - cameraPosition).Unit
				local distanceToItem = (itemPosition - cameraPosition).Magnitude

				-- Raycast from camera to item to check for obstructions
				local raycastParams = RaycastParams.new()

				-- Build filter list - exclude player, placed items, ores, and hotspot folders
				local filterList = {Plr.Character, PLR_PLOT.PlacedItems}
				if PLR_PLOT:FindFirstChild("MinerHotspots") then
					table.insert(filterList, PLR_PLOT.MinerHotspots)
				end
				if PLR_PLOT:FindFirstChild("FurnaceHotspot") then
					table.insert(filterList, PLR_PLOT.FurnaceHotspot)
				end
				if PLR_PLOT:FindFirstChild("Collector") then
					table.insert(filterList, PLR_PLOT.Collector)
				end
				if PLR_PLOT.MiscInfo:FindFirstChild("OresDropped") then
					table.insert(filterList, PLR_PLOT.MiscInfo.OresDropped)
				end

				raycastParams.FilterDescendantsInstances = filterList
				raycastParams.FilterType = Enum.RaycastFilterType.Exclude
				raycastParams.IgnoreWater = true

				local obstructionCheck = workspace:Raycast(cameraPosition, directionToItem * distanceToItem, raycastParams)

				-- If there's no obstruction (or only hit the item itself), show tooltip
				if not obstructionCheck then
					-- No obstruction - item is visible
					local isHotspotMiner = ITEM_HOVERING.Parent:GetAttribute("HotspotMiner") == true
					local isHotspotFurnace = ITEM_HOVERING.Parent:GetAttribute("HotspotFurnace") == true

					-- ALLOW HOVERING (show tooltip) but prevent selection for hotspot items
					if isHotspotMiner or isHotspotFurnace then
						if INPUT.IS_MOBILE then
							if shouldProcessTap then
								HOVER_ITEM(ITEM_HOVERING.Parent)
								mobileHoveredItem = ITEM_HOVERING.Parent
							end
						else
							HOVER_ITEM(ITEM_HOVERING.Parent)
						end

						-- If they try to click, clear any existing selections
						if INPUT.MOUSE_DOWN and not INPUT.IS_MOBILE then
							if module.SELECTING_ITEMS or module.SELECTED_COUNT > 0 then
								module.UNSELECT_ITEMS()
							end
						else
							FINALIZE_SELECTING()
						end
						return
					end

					-- Normal items - Different behavior for mobile vs PC
					if INPUT.IS_MOBILE then
						-- MOBILE BEHAVIOR: Only process when shouldProcessTap is true (new tap detected)
						if shouldProcessTap then
							-- Check if tapping the SAME item that's already showing hover
							if mobileHoveredItem == ITEM_HOVERING.Parent then
								-- SECOND TAP on same item: Show selection menu
								module.UNSELECT_ITEMS()
								CLEAR_HOVER()
								module.SELECT_ITEM(ITEM_HOVERING.Parent)

								-- Immediately finalize to show the selection menu
								module.SELECTING_ITEMS = false
								if module.SELECTED_COUNT > 0 then
									UPDATE_SELECTED_INFO()
									ModernItemSelection.SHOW_MENU(FIRST_SELECTED_ITEM)
								end
							else
								-- FIRST TAP on new item: Show hover tooltip
								if module.SELECTED_COUNT > 0 then
									module.UNSELECT_ITEMS()
								end

								mobileHoveredItem = ITEM_HOVERING.Parent
								HOVER_ITEM(ITEM_HOVERING.Parent)
							end
						end
					else
						-- PC BEHAVIOR: Unchanged
						HOVER_ITEM(ITEM_HOVERING.Parent)
						if INPUT.MOUSE_DOWN then
							if not module.SELECTING_ITEMS then
								module.UNSELECT_ITEMS()
							end
							module.SELECT_ITEM(ITEM_HOVERING.Parent)
						else
							FINALIZE_SELECTING()
						end
					end
				else
					-- Obstruction detected
					if INPUT.IS_MOBILE and shouldProcessTap then
						CLEAR_HOVER(nil)
						mobileHoveredItem = nil
					elseif not INPUT.IS_MOBILE then
						-- PC behavior
						if not INPUT.MOUSE_DOWN then
							FINALIZE_SELECTING()
						elseif INPUT.MOUSE_DOWN and not module.SELECTING_ITEMS then
							module.UNSELECT_ITEMS()
						end
						CLEAR_HOVER(nil)
					end
				end
			else
				-- No item found at tap location
				if INPUT.IS_MOBILE and shouldProcessTap then
					CLEAR_HOVER(nil)
					mobileHoveredItem = nil

					if module.SELECTED_COUNT > 0 then
						module.UNSELECT_ITEMS()
					end
				elseif not INPUT.IS_MOBILE then
					-- PC behavior
					if not INPUT.MOUSE_DOWN then
						FINALIZE_SELECTING()
					elseif INPUT.MOUSE_DOWN and not module.SELECTING_ITEMS then
						module.UNSELECT_ITEMS()
					end
					CLEAR_HOVER(nil)
				end
			end
		end
	end


	function module.BUY_ITEMS()
		if DB then
			DB = false
			local BUYING = {}
			for I, ITEM in pairs(SELECTED_ITEMS) do
				BUYING[#BUYING+1] = require(ITEM.ItemStats).ItemId
			end
			local BUY_ITEMS = RepStorage.Events.BuyItem:InvokeServer(BUYING)
			if BUY_ITEMS then
				module.UNSELECT_ITEMS()
				SELECTED_ITEMS = {}
			end
			wait(.2)
			DB = true
		end
	end


	function module.SELL_ITEMS()
		if DB then
			DB = false
			local SELLING = {}
			for I, ITEM in pairs(SELECTED_ITEMS) do
				SELLING[#SELLING+1] = ITEM
			end
			local SELL_ITEMS = RepStorage.Events.SellItem:InvokeServer(SELLING)
			if SELL_ITEMS then
				module.UNSELECT_ITEMS()
				SELECTED_ITEMS = {}
			end
			wait(.2)
			DB = true
		end
	end

	function module.MOVE_ITEMS()
		if DB then
			DB = false

			-- FIRST: Clone all selected items to preserve their properties/configurations
			local MOVING = {}
			local WITHDRAWING = {}

			for I, ITEM in pairs(SELECTED_ITEMS) do
				-- Clone the actual item (preserves all configurations, attributes, etc.)
				MOVING[#MOVING+1] = ITEM:Clone()
				-- Queue original for withdrawal
				WITHDRAWING[#WITHDRAWING+1] = ITEM
			end

			-- Start placement with the clones BEFORE withdrawing
			-- This way the clones appear immediately
			local PLACING_STARTED = PLACEMENT.BEGIN_PLACING(MOVING, true)

			if PLACING_STARTED then
				-- NOW withdraw the originals (they disappear right after clones appear)
				RepStorage.Events.WithdrawItems:InvokeServer(WITHDRAWING)

				module.UNSELECT_ITEMS()
				SELECTED_ITEMS = {}
			end

			wait(.2)
			DB = true
		end
	end

	function module.WITHDRAW_ITEM()
		if DB then
			DB = false
			local WITHDRAWING = {}
			for I, ITEM in pairs(SELECTED_ITEMS) do
				WITHDRAWING[#WITHDRAWING+1] = ITEM
			end
			local WITHDRAW_ITEMS = RepStorage.Events.WithdrawItems:InvokeServer(WITHDRAWING)
			if WITHDRAW_ITEMS then
				module.UNSELECT_ITEMS()
				SELECTED_ITEMS = {}
			end
			wait(.2)
			DB = true
		end
	end

	-- Connect modern UI buttons
	modernUI.WithdrawButton.MouseButton1Click:Connect(function()
		SoundManager.ButtonClick()
		module.WITHDRAW_ITEM()
	end)

	modernUI.MoveButton.MouseButton1Click:Connect(function()
		SoundManager.ButtonClick()
		module.MOVE_ITEMS()
	end)

	modernUI.BuyButton.MouseButton1Click:Connect(function()
		SoundManager.ButtonClick()
		module.BUY_ITEMS()
	end)

	modernUI.SellButton.MouseButton1Click:Connect(function()
		SoundManager.ButtonClick()
		module.SELL_ITEMS()
	end)
end

return module
