local module = {}

function module.SELECT_ITEM()
	warn("ItemSelection.SELECT_ITEM() HASN'T LOADED YET!")
end

function module.ITEM_DETECT()
	warn("ItemSelection.ITEM_DETECT() HASN'T LOADED YET!")
end

function module.LOAD(MODULE_INFO)
	-- Basic Needs
	local MODULES = MODULE_INFO["MODULES"]
	local SERVICES = MODULE_INFO["SERVICES"]
	-- Services
	local InputService = SERVICES["UserInputService"]
	local RepStorage = SERVICES["ReplicatedStorage"]
	local RunService = SERVICES["RunService"]
	local Plrs = SERVICES["Players"]
	-- Modules
	local ITEM_HOVER = MODULES["ItemHover"]
	local PLACEMENT = MODULES["Placement"]
	local MainLib = MODULES["MainLib"]
	local INPUT = MODULES["Input"]
	local ModernItemSelection = MODULES["ModernItemSelection"]
	local CASH_LIB = MODULES["CashLib"]  -- For number formatting
	local SoundManager = require(RepStorage.Modules.SoundManager)
	-- Plr Info
	local Plr = Plrs.LocalPlayer
	local Mouse = Plr:GetMouse()
	local PLR_PLOT = Plr.SetPlot.Value
	-- Variables
	-- Booleans
	local DB = true
	module.SELECTING_ITEMS = false
	-- Arrays
	local SELECTED_ITEMS = {}
	-- Integers
	module.SELECTED_COUNT = 0
	-- Objects
	local CURRENT_HOVER = nil
	local FIRST_SELECTED_ITEM = nil  -- Track first selected item for anchoring

	-- Create modern UI
	local modernUI = ModernItemSelection.CREATE_MODERN_SELECTION_UI(script.Parent.Parent)
	modernUI.Container.Visible = false

	-- Hide old ItemSelection GUI
	script.Parent.Parent.ItemSelection.Enabled = false
	script.Parent.Parent.ItemSelection.Adornee = nil

	-- Update menu position every frame when visible
	RunService.RenderStepped:Connect(function()
		if modernUI.Container.Visible and FIRST_SELECTED_ITEM then
			modernUI.UpdatePosition()
		end
	end)

	local function UPDATE_SELECTED_INFO()
		if module.SELECTED_COUNT == 1 then
			for I, ITEM_INFO in pairs(SELECTED_ITEMS) do
				modernUI.ItemName.Text = ITEM_INFO.Name
				local TIER_NAME, TIER_INFO = MainLib.GET_ITEM_TIER_INFO(ITEM_INFO.Name)
				modernUI.ItemTier.Text = TIER_NAME
				modernUI.ItemTier.TextColor3 = TIER_INFO["TIER_COLOR"]
				FIRST_SELECTED_ITEM = ITEM_INFO  -- Store for anchoring

				-- Get item stats and set prices
				if ITEM_INFO:FindFirstChild("ItemStats") then
					local itemStats = require(ITEM_INFO.ItemStats)
					local buyPrice = itemStats.Cost or 0
					local sellPrice = math.floor(buyPrice * 0.3)  -- Sell price is 30% of buy price

					-- Update price labels (includes button name in text)
					if modernUI.BuyPrice then
						modernUI.BuyPrice.Text = "Buy - " .. CASH_LIB.SUFFIX_NUM(buyPrice)
					end
					if modernUI.SellPrice then
						modernUI.SellPrice.Text = "Sell - " .. CASH_LIB.SUFFIX_NUM(sellPrice)
					end
				end
			end
		else
			modernUI.ItemName.Text = "Multi-Select"
			modernUI.ItemTier.TextColor3 = Color3.fromRGB(140, 140, 140)
			modernUI.ItemTier.Text = "Item Count: "..module.SELECTED_COUNT

			-- For multi-select, calculate total value
			local totalBuyPrice = 0
			local totalSellPrice = 0
			for I, ITEM_INFO in pairs(SELECTED_ITEMS) do
				if ITEM_INFO:FindFirstChild("ItemStats") then
					local itemStats = require(ITEM_INFO.ItemStats)
					local itemBuyPrice = itemStats.Cost or 0
					totalBuyPrice = totalBuyPrice + itemBuyPrice
					totalSellPrice = totalSellPrice + math.floor(itemBuyPrice * 0.3)  -- 30% of buy price
				end
				if I == 1 then
					FIRST_SELECTED_ITEM = ITEM_INFO
				end
			end

			-- Update price labels (includes button name in text)
			if modernUI.BuyPrice then
				modernUI.BuyPrice.Text = "Buy - " .. CASH_LIB.SUFFIX_NUM(totalBuyPrice)
			end
			if modernUI.SellPrice then
				modernUI.SellPrice.Text = "Sell - " .. CASH_LIB.SUFFIX_NUM(totalSellPrice)
			end
		end
	end

	function module.SELECT_ITEM(ITEM)
		module.SELECTING_ITEMS = true
		for I, ITEM in pairs(SELECTED_ITEMS) do
			ITEM:SetAttribute("SELECTED", true)
			if ITEM:FindFirstChild("Hitbox") then
				ITEM.Hitbox.Transparency = .7
			end
		end
		if SELECTED_ITEMS[ITEM] ~= ITEM then
			SELECTED_ITEMS[ITEM] = ITEM
			if ITEM:FindFirstChild("Hitbox") then
				ITEM.Hitbox.Transparency = .7
				module.SELECTED_COUNT += 1
			end
			UPDATE_SELECTED_INFO()
		end
		-- IMPORTANT: Hide tooltip and clear hover reference when selecting
		if ITEM_HOVER.ModernHover then
			ITEM_HOVER.ModernHover.Hide()
		end
		if script.Parent.Parent.ItemHover:FindFirstChild("HoveredItemRef") then
			script.Parent.Parent.ItemHover.HoveredItemRef.Value = nil
		end
	end

	function module.UNSELECT_ITEMS()
		for I, ITEM in pairs(SELECTED_ITEMS) do
			ITEM:SetAttribute("SELECTED", nil)
			if ITEM:FindFirstChild("Hitbox") then
				ITEM.Hitbox.Transparency = 1
			end
			SELECTED_ITEMS[ITEM] = nil
		end
		module.SELECTED_COUNT = 0
		SELECTED_ITEMS = {}
		FIRST_SELECTED_ITEM = nil
		ModernItemSelection.HIDE_MENU()
	end

	local function CLEAR_HOVER(ITEM)
		local ITEM = ITEM or nil
		local CURRENT_HOVER_BACKUP = CURRENT_HOVER
		if CURRENT_HOVER ~= ITEM then
			-- Hide modern hover UI
			if ITEM_HOVER.ModernHover then
				ITEM_HOVER.ModernHover.Hide()
			end

			-- Clear the item reference
			if script.Parent.Parent.ItemHover:FindFirstChild("HoveredItemRef") then
				script.Parent.Parent.ItemHover.HoveredItemRef.Value = nil
			end

			if CURRENT_HOVER_BACKUP ~= nil and not CURRENT_HOVER_BACKUP:GetAttribute("SELECTED") then
				if CURRENT_HOVER_BACKUP:FindFirstChild("Hitbox") then
					CURRENT_HOVER_BACKUP.Hitbox.Transparency = 1
				end
				if CURRENT_HOVER == CURRENT_HOVER_BACKUP then
					CURRENT_HOVER = nil
				end
			end
		end
	end

	local function HOVER_ITEM(ITEM)
		-- Clear hovering items
		if CURRENT_HOVER ~= nil then
			CLEAR_HOVER(ITEM)
		end
		if ITEM ~= nil and SELECTED_ITEMS[ITEM] ~= ITEM then
			-- Set the item to be a item that is being hovered
			if CURRENT_HOVER ~= ITEM then
				CURRENT_HOVER = ITEM
				if ITEM:FindFirstChild("Hitbox") then
					ITEM.Hitbox.Transparency = .85
				end
			end

			-- Only show tooltip if we're not in selection mode
			if not module.SELECTING_ITEMS and module.SELECTED_COUNT == 0 then
				-- Use modern hover UI
				if ITEM_HOVER.ModernHover then
					local TIER_NAME, TIER_INFO = MainLib.GET_ITEM_TIER_INFO(ITEM.Name)
					ITEM_HOVER.ModernHover.ItemTier.TextColor3 = TIER_INFO["TIER_COLOR"]
					ITEM_HOVER.ModernHover.ItemTier.Text = TIER_NAME
					ITEM_HOVER.ModernHover.ItemName.Text = ITEM.Name

					-- Show compact view for placed items
					ITEM_HOVER.ModernHover.ShowCompact()
					ITEM_HOVER.ModernHover.Show()
				end

				-- Store reference to the actual item object
				if not script.Parent.Parent.ItemHover:FindFirstChild("HoveredItemRef") then
					local objValue = Instance.new("ObjectValue")
					objValue.Name = "HoveredItemRef"
					objValue.Parent = script.Parent.Parent.ItemHover
				end
				script.Parent.Parent.ItemHover.HoveredItemRef.Value = ITEM

				ITEM_HOVER.UPDATE_HOVER()
			end
		end
	end

	local function FINALIZE_SELECTING()
		module.SELECTING_ITEMS = false
		if module.SELECTED_COUNT > 0 then
			UPDATE_SELECTED_INFO()
			ModernItemSelection.SHOW_MENU(FIRST_SELECTED_ITEM)
		end
	end

	-- Replace your existing module.ITEM_DETECT() function with this:

	function module.ITEM_DETECT()
		if PLACEMENT.PLACING_ITEMS then		-- Big no no for item selection :)
			CLEAR_HOVER()
			return
		end
		if #script.Parent.Parent.Values.OpenedMenus:GetChildren() > 0 then		-- No item selection if a menu is open (Prevents bugs with the hovering of items.)
			CLEAR_HOVER()
			return
		end
		local ITEM_CAST_POINT
		if Mouse and InputService.MouseEnabled then
			ITEM_CAST_POINT = Vector2.new(Mouse.X, Mouse.Y + 36)
		else
			local CAM_SIZE = workspace.CurrentCamera.ViewportSize
			ITEM_CAST_POINT = Vector2.new(math.floor(CAM_SIZE.X/2),math.floor(CAM_SIZE.Y/3))
		end
		local CAM_RAY = workspace.CurrentCamera:ViewportPointToRay(ITEM_CAST_POINT.X, ITEM_CAST_POINT.Y)
		local SELECTION_RAY = Ray.new(CAM_RAY.Origin, CAM_RAY.Direction * 1000)
		if PLR_PLOT ~= nil then
			local ITEM_HOVERING = workspace:FindPartOnRayWithWhitelist(SELECTION_RAY, PLR_PLOT.PlacedItems:GetChildren())
			if ITEM_HOVERING and ITEM_HOVERING.Parent:FindFirstChild("ItemStats") then

				local isHotspotMiner = ITEM_HOVERING.Parent:GetAttribute("HotspotMiner") == true
				local isHotspotFurnace = ITEM_HOVERING.Parent:GetAttribute("HotspotFurnace") == true

				-- ALLOW HOVERING (show tooltip) but prevent selection for hotspot items
				if isHotspotMiner or isHotspotFurnace then
					HOVER_ITEM(ITEM_HOVERING.Parent)

					-- If they try to click, clear any existing selections
					if INPUT.MOUSE_DOWN then
						if module.SELECTING_ITEMS or module.SELECTED_COUNT > 0 then
							module.UNSELECT_ITEMS()
						end
					else
						FINALIZE_SELECTING()
					end
					return
				end

				-- Normal items - allow full interaction
				HOVER_ITEM(ITEM_HOVERING.Parent)
				if INPUT.MOUSE_DOWN then
					if not module.SELECTING_ITEMS then		-- Wipe previously selected items
						module.UNSELECT_ITEMS()
					end
					module.SELECT_ITEM(ITEM_HOVERING.Parent)
				else
					FINALIZE_SELECTING()
				end
			else
				if not INPUT.MOUSE_DOWN then
					FINALIZE_SELECTING()
				elseif INPUT.MOUSE_DOWN and not module.SELECTING_ITEMS then
					module.UNSELECT_ITEMS()
				end
				CLEAR_HOVER(nil)
			end
		end
	end


	function module.BUY_ITEMS()
		if DB then
			DB = false
			local BUYING = {}
			for I, ITEM in pairs(SELECTED_ITEMS) do
				BUYING[#BUYING+1] = require(ITEM.ItemStats).ItemId
			end
			local BUY_ITEMS = RepStorage.Events.BuyItem:InvokeServer(BUYING)
			if BUY_ITEMS then
				module.UNSELECT_ITEMS()
				SELECTED_ITEMS = {}
			end
			wait(.2)
			DB = true
		end
	end


	function module.SELL_ITEMS()
		if DB then
			DB = false
			local SELLING = {}
			for I, ITEM in pairs(SELECTED_ITEMS) do
				SELLING[#SELLING+1] = ITEM
			end
			local SELL_ITEMS = RepStorage.Events.SellItem:InvokeServer(SELLING)
			if SELL_ITEMS then
				module.UNSELECT_ITEMS()
				SELECTED_ITEMS = {}
			end
			wait(.2)
			DB = true
		end
	end

	function module.MOVE_ITEMS()
		if DB then
			DB = false

			-- FIRST: Clone all selected items to preserve their properties/configurations
			local MOVING = {}
			local WITHDRAWING = {}

			for I, ITEM in pairs(SELECTED_ITEMS) do
				-- Clone the actual item (preserves all configurations, attributes, etc.)
				MOVING[#MOVING+1] = ITEM:Clone()
				-- Queue original for withdrawal
				WITHDRAWING[#WITHDRAWING+1] = ITEM
			end

			-- Start placement with the clones BEFORE withdrawing
			-- This way the clones appear immediately
			local PLACING_STARTED = PLACEMENT.BEGIN_PLACING(MOVING, true)

			if PLACING_STARTED then
				-- NOW withdraw the originals (they disappear right after clones appear)
				RepStorage.Events.WithdrawItems:InvokeServer(WITHDRAWING)

				module.UNSELECT_ITEMS()
				SELECTED_ITEMS = {}
			end

			wait(.2)
			DB = true
		end
	end

	function module.WITHDRAW_ITEM()
		if DB then
			DB = false
			local WITHDRAWING = {}
			for I, ITEM in pairs(SELECTED_ITEMS) do
				WITHDRAWING[#WITHDRAWING+1] = ITEM
			end
			local WITHDRAW_ITEMS = RepStorage.Events.WithdrawItems:InvokeServer(WITHDRAWING)
			if WITHDRAW_ITEMS then
				module.UNSELECT_ITEMS()
				SELECTED_ITEMS = {}
			end
			wait(.2)
			DB = true
		end
	end

	-- Connect modern UI buttons
	modernUI.WithdrawButton.MouseButton1Click:Connect(function()
		SoundManager.ButtonClick()
		module.WITHDRAW_ITEM()
	end)

	modernUI.MoveButton.MouseButton1Click:Connect(function()
		SoundManager.ButtonClick()
		module.MOVE_ITEMS()
	end)

	modernUI.BuyButton.MouseButton1Click:Connect(function()
		SoundManager.ButtonClick()
		module.BUY_ITEMS()
	end)

	modernUI.SellButton.MouseButton1Click:Connect(function()
		SoundManager.ButtonClick()
		module.SELL_ITEMS()
	end)
end

return module
