-- ReplicatedStorage/Items/[Miner]/DropOre.lua
-- REPLACE the SelectRandomOre function with this updated version

local Plrs = game:GetService("Players")
local RepStorage = game:GetService("ReplicatedStorage")
local ITEM_HANDLER = require(RepStorage.Modules.ItemHandler)
local ITEM_INFO = require(script.Parent.Parent.ItemStats)
local PLOT = script.Parent.Parent.Parent.Parent

-- Random spread settings
local SPREAD_WIDTH = 2

-- Function to select a random ore based on weighted chances
local function SelectRandomOre()
	local dropTable = ITEM_INFO.DropTable
	if not dropTable or #dropTable == 0 then
		return ITEM_INFO.OreModelName, ITEM_INFO.DropWorth
	end

	-- Get gem discovery boost
	local gemBoostMultiplier = 1
	local plot_owner = Plrs:FindFirstChild(PLOT.Owner.Value)
	if plot_owner and _G.GetUpgradeMultiplier then
		gemBoostMultiplier = _G.GetUpgradeMultiplier(plot_owner, "GemDiscovery")
	end

	-- Build adjusted drop table
	local adjustedTable = {}
	local commonOreChance = 0
	local totalGemBonus = 0

	-- First pass: identify gems and calculate total boost
	for _, dropData in ipairs(dropTable) do
		local isGem = dropData.Name:find("Gem") ~= nil

		if isGem then
			-- Boost gem chances
			local boostedChance = dropData.Chance * gemBoostMultiplier
			table.insert(adjustedTable, {
				Name = dropData.Name,
				Worth = dropData.Worth,
				Chance = boostedChance,
				IsGem = true
			})
			totalGemBonus = totalGemBonus + (boostedChance - dropData.Chance)
		else
			-- Track common ore
			commonOreChance = commonOreChance + dropData.Chance
			table.insert(adjustedTable, {
				Name = dropData.Name,
				Worth = dropData.Worth,
				Chance = dropData.Chance,
				IsGem = false
			})
		end
	end

	-- Second pass: reduce common ore chances to keep total at 100%
	for i, item in ipairs(adjustedTable) do
		if not item.IsGem then
			-- Reduce proportionally
			local reductionRatio = (commonOreChance - totalGemBonus) / commonOreChance
			adjustedTable[i].Chance = item.Chance * reductionRatio
		end
	end

	-- Select random ore from adjusted table
	local roll = math.random() * 100
	local accumulated = 0

	for _, dropData in ipairs(adjustedTable) do
		accumulated = accumulated + dropData.Chance
		if roll <= accumulated then
			return dropData.Name, dropData.Worth
		end
	end

	-- Fallback
	return adjustedTable[1].Name, adjustedTable[1].Worth
end

-- Function to calculate wait time with speed upgrade applied
local function GetWaitTime()
	local baseMin = ITEM_INFO.DropSpeedMin
	local baseMax = ITEM_INFO.DropSpeedMax

	local upgradeLevel = script.Parent.Parent:GetAttribute("SpeedUpgradeLevel") or 0
	local speedMultiplier = 1 + (upgradeLevel * 0.05)

	local adjustedMin = baseMin / speedMultiplier
	local adjustedMax = baseMax / speedMultiplier

	local waitTime = adjustedMin + math.random() * (adjustedMax - adjustedMin)

	return waitTime
end

while true do
	local waitTime = GetWaitTime()
	wait(waitTime)

	local plot_owner = Plrs:FindFirstChild(PLOT.Owner.Value)
	if plot_owner ~= nil then
		if plot_owner.Settings.MinesActive.Value then
			local selectedOreName, selectedWorth = SelectRandomOre()

			local ORE, CASH_VALUE = ITEM_HANDLER.DROP_ORE(
				PLOT, 
				script.Parent.Parent, 
				script.Parent.Drop, 
				Vector3.new(ITEM_INFO.DropSize, ITEM_INFO.DropSize, ITEM_INFO.DropSize), 
				ITEM_INFO.DropColor, 
				ITEM_INFO.DropMaterial, 
				selectedWorth,
				selectedOreName
			)

			if ORE then
				local randomX = math.random(-SPREAD_WIDTH/2 * 100, SPREAD_WIDTH/2 * 100) / 100

				local currentCFrame
				if ORE:IsA("Model") then
					currentCFrame = ORE:GetPivot()
					local newCFrame = currentCFrame * CFrame.new(randomX, 0, 0)
					ORE:PivotTo(newCFrame)
				elseif ORE:IsA("BasePart") then
					currentCFrame = ORE.CFrame
					ORE.CFrame = currentCFrame * CFrame.new(randomX, 0, 0)
				end

				ORE.Parent = PLOT.MiscInfo.OresDropped

				if ORE:IsA("Model") then
					if ORE.PrimaryPart then
						ORE.PrimaryPart:SetNetworkOwner(plot_owner)
					end
				elseif ORE:IsA("BasePart") then
					ORE:SetNetworkOwner(plot_owner)
				end
			end
		end
	end
end
