local RepStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local CONVEYOR_PART = script.Parent

if not CONVEYOR_PART or not CONVEYOR_PART:IsA("BasePart") then
	warn("SlopedConveyorMove script must be inside the Conv/ConvMerge part!")
	return
end

-- Find ItemStats by going up the hierarchy
local function findItemStats(startPart)
	local current = startPart
	while current and current ~= game do
		local itemStats = current:FindFirstChild("ItemStats")
		if itemStats then
			return itemStats
		end
		current = current.Parent
	end
	return nil
end

local itemStatsModule = findItemStats(CONVEYOR_PART)

-- DEFAULT SPEED if ItemStats not found
local DEFAULT_SPEED = 12

local ITEM_INFO
if itemStatsModule then
	ITEM_INFO = require(itemStatsModule)
	print("Found ItemStats, speed:", ITEM_INFO.ConveyorSpeed)
else
	warn("Could not find ItemStats for sloped conveyor, using default speed:", DEFAULT_SPEED)
	ITEM_INFO = {ConveyorSpeed = DEFAULT_SPEED}
end

-- Check if this conveyor can flip (has ConvVelo)
local ConvVelo = CONVEYOR_PART:WaitForChild("ConvVelo", 2)
local canFlip = ConvVelo ~= nil

if canFlip then
	print("Sloped conveyor initialized (FLIPPABLE), initial speed:", ConvVelo.Value)
else
	print("Sloped conveyor initialized (NON-FLIPPABLE), speed:", ITEM_INFO.ConveyorSpeed)
end

local DETECTION_HEIGHT = 3

local function isOre(part)
	-- Check if this part is an ore or belongs to an ore model
	if part:FindFirstChild("Cash") then
		return true, part
	end

	if part.Parent and part.Parent:IsA("Model") and part.Parent:FindFirstChild("Cash") then
		return true, part.Parent.PrimaryPart or part
	end

	return false, nil
end

local function isOreOnThisConveyor(orePart)
	-- Transform ore position to conveyor's local space
	local localPos = CONVEYOR_PART.CFrame:PointToObjectSpace(orePart.Position)
	local halfSize = CONVEYOR_PART.Size / 2

	-- Check if ore is within the conveyor's bounds (with small margins)
	local marginX = 0.5
	local marginY = 2.5 -- Height tolerance
	local marginZ = 0.5

	local withinX = math.abs(localPos.X) <= (halfSize.X + marginX)
	local withinY = math.abs(localPos.Y) <= (halfSize.Y + marginY)
	local withinZ = math.abs(localPos.Z) <= (halfSize.Z + marginZ)

	-- Ore must be within ALL bounds
	return withinX and withinY and withinZ
end

-- Continuously detect and move ores on the conveyor
RunService.Heartbeat:Connect(function()
	-- Get speed from ConvVelo if it exists (flippable), otherwise use ItemStats (non-flippable)
	local SPEED = canFlip and ConvVelo.Value or ITEM_INFO.ConveyorSpeed

	-- Calculate detection region (box above the conveyor)
	local conveyorCFrame = CONVEYOR_PART.CFrame
	local conveyorSize = CONVEYOR_PART.Size

	-- Create detection box that matches conveyor size closely
	local detectionSize = Vector3.new(
		conveyorSize.X,
		DETECTION_HEIGHT,
		conveyorSize.Z
	)

	local detectionCFrame = conveyorCFrame * CFrame.new(0, DETECTION_HEIGHT/2, 0)

	-- Get all parts in this region
	local partsInRegion = workspace:GetPartBoundsInBox(detectionCFrame, detectionSize)

	-- Move any ores found in the region that are actually on THIS conveyor
	for _, part in pairs(partsInRegion) do
		local isAnOre, orePart = isOre(part)

		-- IMPORTANT: Check if ore is actually within conveyor bounds
		if isAnOre and orePart and isOreOnThisConveyor(orePart) then
			-- Apply velocity to move the ore along the conveyor
			orePart.AssemblyLinearVelocity = CONVEYOR_PART.CFrame.LookVector * SPEED

			-- Optional: Apply slight downward force to keep ore pressed against conveyor
			-- This helps irregular shapes maintain contact
			local downwardForce = -CONVEYOR_PART.CFrame.UpVector * 5
			orePart.AssemblyLinearVelocity = (CONVEYOR_PART.CFrame.LookVector * SPEED) + downwardForce
		end
	end
end)
