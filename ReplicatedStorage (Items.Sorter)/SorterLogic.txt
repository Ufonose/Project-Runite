local RepStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local ITEM_INFO = require(script.Parent.ItemStats)
local PLOT = script.Parent.Parent.Parent.Parent

local SORTER = script.Parent
local SORT_DETECTOR = SORTER:WaitForChild("SortDetector")

-- Storage for sort configuration (player configurable)
if not SORTER:FindFirstChild("SortConfig") then
	local config = Instance.new("Folder")
	config.Name = "SortConfig"
	config.Parent = SORTER
end

local SORT_CONFIG = SORTER.SortConfig

-- Detection settings
local DETECTION_HEIGHT = 3
local trackedOres = {} -- Track ores and their assigned directions

-- Helper to get ore info
local function getOreInfo(part)
	local ore = nil
	local oreModelName = nil

	-- Check if part itself is ore
	if part:FindFirstChild("Cash") and part:FindFirstChild("OreModelName") then
		ore = part
		oreModelName = part.OreModelName.Value
		-- Check if parent model is ore
	elseif part.Parent and part.Parent:IsA("Model") and part.Parent:FindFirstChild("Cash") and part.Parent:FindFirstChild("OreModelName") then
		ore = part.Parent:FindFirstChildWhichIsA("BasePart")
		oreModelName = part.Parent.OreModelName.Value
	end

	return ore, oreModelName
end

-- Get sort direction for an ore type
local function getSortDirection(oreModelName)
	local config = SORT_CONFIG:FindFirstChild(oreModelName)
	if config and config:IsA("StringValue") then
		return config.Value -- "Left", "Right", or "Straight"
	end
	return "Straight" -- Default: straight through
end

-- Calculate sort velocity
local function getSortVelocity(direction)
	local baseCFrame = SORT_DETECTOR.CFrame
	local speed = ITEM_INFO.SortSpeed

	if direction == "Left" then
		-- Rotate left by SortAngle degrees
		local angle = math.rad(ITEM_INFO.SortAngle)
		return (baseCFrame * CFrame.Angles(0, angle, 0)).LookVector * speed
	elseif direction == "Right" then
		-- Rotate right by SortAngle degrees
		local angle = math.rad(-ITEM_INFO.SortAngle)
		return (baseCFrame * CFrame.Angles(0, angle, 0)).LookVector * speed
	else -- "Straight"
		return baseCFrame.LookVector * speed
	end
end

-- Check if ore is within sorter bounds
local function isOreOnSorter(orePart)
	local localPos = SORT_DETECTOR.CFrame:PointToObjectSpace(orePart.Position)
	local halfSize = SORT_DETECTOR.Size / 2

	local marginX = 0.5
	local marginY = 2.5
	local marginZ = 0.5

	local withinX = math.abs(localPos.X) <= (halfSize.X + marginX)
	local withinY = math.abs(localPos.Y) <= (halfSize.Y + marginY)
	local withinZ = math.abs(localPos.Z) <= (halfSize.Z + marginZ)

	return withinX and withinY and withinZ
end

-- Track ores entering the sorter
SORT_DETECTOR.Touched:Connect(function(hit)
	local ore, oreModelName = getOreInfo(hit)

	if ore and oreModelName and not trackedOres[ore] then
		local direction = getSortDirection(oreModelName)

		trackedOres[ore] = {
			direction = direction,
			startTime = tick(),
			startPosition = ore.Position,
			showedMessage = false
		}

		print("Ore entered sorter:", oreModelName, "->", direction)
	end
end)

-- Continuously move ores through the sorter
RunService.Heartbeat:Connect(function()
	-- Get all parts in detection region
	local detectionSize = Vector3.new(
		SORT_DETECTOR.Size.X,
		DETECTION_HEIGHT,
		SORT_DETECTOR.Size.Z
	)

	local detectionCFrame = SORT_DETECTOR.CFrame * CFrame.new(0, DETECTION_HEIGHT/2, 0)
	local partsInRegion = workspace:GetPartBoundsInBox(detectionCFrame, detectionSize)

	-- Update tracked ores
	for ore, data in pairs(trackedOres) do
		-- Clean up if ore destroyed
		if not ore.Parent then
			trackedOres[ore] = nil
			-- Clean up if traveled too far or too much time
		elseif (ore.Position - data.startPosition).Magnitude > SORT_DETECTOR.Size.Z * 3 or (tick() - data.startTime) > 5 then
			trackedOres[ore] = nil
			-- Keep moving if still on sorter
		elseif isOreOnSorter(ore) then
			local velocity = getSortVelocity(data.direction)
			ore.AssemblyLinearVelocity = velocity

			-- Show visual feedback once
			if not data.showedMessage then
				data.showedMessage = true

				local plotOwner = game.Players:FindFirstChild(PLOT.Owner.Value)
				if plotOwner then
					RepStorage.Events.MessageClient:FireClient(
						plotOwner,
						"visual",
						{
							["visual_part"] = SORT_DETECTOR,
							["message"] = data.direction == "Straight" and "‚Üë" or (data.direction == "Left" and "‚Üê" or "‚Üí"),
							["message_color"] = data.direction == "Straight" and Color3.fromRGB(200, 200, 200) or (data.direction == "Left" and Color3.fromRGB(255, 150, 150) or Color3.fromRGB(150, 150, 255)),
							["message_time"] = 0.5
						}
					)
				end
			end
		else
			-- Ore left the sorter
			trackedOres[ore] = nil
		end
	end

	-- Check for new ores in region
	for _, part in pairs(partsInRegion) do
		local ore, oreModelName = getOreInfo(part)

		if ore and oreModelName and not trackedOres[ore] and isOreOnSorter(ore) then
			local direction = getSortDirection(oreModelName)

			trackedOres[ore] = {
				direction = direction,
				startTime = tick(),
				startPosition = ore.Position,
				showedMessage = false
			}
		end
	end
end)

-- Display current configuration on SurfaceGui screen with two columns
local function updateDisplay()
	-- Find the screen part and its SurfaceGui
	local screen = SORTER:FindFirstChild("Screen")
	if not screen then 
		warn("No Screen part found in sorter!")
		return 
	end

	local displayGui = screen:FindFirstChild("DisplayGui")
	if not displayGui then 
		warn("No DisplayGui found on Screen!")
		return 
	end

	-- Clear existing content
	displayGui:ClearAllChildren()

	-- Main container
	local mainFrame = Instance.new("Frame")
	mainFrame.Name = "MainFrame"
	mainFrame.Size = UDim2.new(1, 0, 1, 0)
	mainFrame.BackgroundColor3 = Color3.fromRGB(10, 10, 15)
	mainFrame.BorderSizePixel = 0
	mainFrame.Parent = displayGui

	-- Title bar (smaller)
	local titleBar = Instance.new("Frame")
	titleBar.Size = UDim2.new(1, 0, 0, 22) -- Even smaller
	titleBar.BackgroundColor3 = Color3.fromRGB(15, 15, 20)
	titleBar.BorderSizePixel = 0
	titleBar.Parent = mainFrame

	local titleLabel = Instance.new("TextLabel")
	titleLabel.Size = UDim2.new(1, 0, 1, 0)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Text = "üì¶ SORTER CONFIG"
	titleLabel.TextColor3 = Color3.fromRGB(100, 200, 255)
	titleLabel.TextSize = 8
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.Parent = titleBar

	-- Left column header (closer to title)
	local leftHeader = Instance.new("Frame")
	leftHeader.Size = UDim2.new(0.48, 0, 0, 18) -- Smaller
	leftHeader.Position = UDim2.new(0, 5, 0, 24) -- Much closer to title
	leftHeader.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
	leftHeader.BorderSizePixel = 0
	leftHeader.Parent = mainFrame

	local leftHeaderText = Instance.new("TextLabel")
	leftHeaderText.Size = UDim2.new(1, 0, 1, 0)
	leftHeaderText.BackgroundTransparency = 1
	leftHeaderText.Text = "‚Üê LEFT"
	leftHeaderText.TextColor3 = Color3.fromRGB(255, 150, 150)
	leftHeaderText.TextSize = 8
	leftHeaderText.Font = Enum.Font.GothamBold
	leftHeaderText.Parent = leftHeader

	-- Right column header (closer to title)
	local rightHeader = Instance.new("Frame")
	rightHeader.Size = UDim2.new(0.48, 0, 0, 18) -- Smaller
	rightHeader.Position = UDim2.new(0.52, 0, 0, 24) -- Much closer to title
	rightHeader.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
	rightHeader.BorderSizePixel = 0
	rightHeader.Parent = mainFrame

	local rightHeaderText = Instance.new("TextLabel")
	rightHeaderText.Size = UDim2.new(1, 0, 1, 0)
	rightHeaderText.BackgroundTransparency = 1
	rightHeaderText.Text = "RIGHT ‚Üí"
	rightHeaderText.TextColor3 = Color3.fromRGB(150, 150, 255)
	rightHeaderText.TextSize = 8
	rightHeaderText.Font = Enum.Font.GothamBold
	rightHeaderText.Parent = rightHeader

	-- Center divider line
	local divider = Instance.new("Frame")
	divider.Size = UDim2.new(0, 1, 1, -10) -- Adjusted
	divider.Position = UDim2.new(0.5, -1, 0, 24) -- Adjusted
	divider.BackgroundColor3 = Color3.fromRGB(100, 200, 255)
	divider.BorderSizePixel = 0
	divider.Parent = mainFrame

	-- Left scroll frame (closer to headers)
	local leftScroll = Instance.new("ScrollingFrame")
	leftScroll.Size = UDim2.new(0.48, -5, 1, -48) -- Takes up more space now
	leftScroll.Position = UDim2.new(0, 5, 0, 44) -- Closer to header
	leftScroll.BackgroundColor3 = Color3.fromRGB(15, 15, 20)
	leftScroll.BorderSizePixel = 0
	leftScroll.ScrollBarThickness = 3
	leftScroll.ScrollBarImageColor3 = Color3.fromRGB(100, 200, 255)
	leftScroll.Parent = mainFrame

	local leftLayout = Instance.new("UIListLayout")
	leftLayout.Padding = UDim.new(0, 2)
	leftLayout.SortOrder = Enum.SortOrder.Name
	leftLayout.Parent = leftScroll

	-- Right scroll frame (closer to headers)
	local rightScroll = Instance.new("ScrollingFrame")
	rightScroll.Size = UDim2.new(0.48, -5, 1, -48) -- Takes up more space now
	rightScroll.Position = UDim2.new(0.52, 5, 0, 44) -- Closer to header
	rightScroll.BackgroundColor3 = Color3.fromRGB(15, 15, 20)
	rightScroll.BorderSizePixel = 0
	rightScroll.ScrollBarThickness = 3
	rightScroll.ScrollBarImageColor3 = Color3.fromRGB(100, 200, 255)
	rightScroll.Parent = mainFrame

	local rightLayout = Instance.new("UIListLayout")
	rightLayout.Padding = UDim.new(0, 2)
	rightLayout.SortOrder = Enum.SortOrder.Name
	rightLayout.Parent = rightScroll

	-- Collect configs
	local leftItems = {}
	local rightItems = {}

	for _, config in pairs(SORT_CONFIG:GetChildren()) do
		if config:IsA("StringValue") then
			local oreName = config.Name:gsub("OreModel", ""):gsub("_", " ")

			if config.Value == "Left" then
				table.insert(leftItems, oreName)
			elseif config.Value == "Right" then
				table.insert(rightItems, oreName)
			end
			-- Straight items are ignored now
		end
	end

	-- Sort alphabetically
	table.sort(leftItems)
	table.sort(rightItems)

	-- Create left items
	if #leftItems == 0 then
		local emptyLabel = Instance.new("TextLabel")
		emptyLabel.Size = UDim2.new(1, 0, 0, 15)
		emptyLabel.BackgroundTransparency = 1
		emptyLabel.Text = "(None)"
		emptyLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
		emptyLabel.TextSize = 7
		emptyLabel.Font = Enum.Font.Code
		emptyLabel.Parent = leftScroll
	else
		for _, oreName in ipairs(leftItems) do
			local oreLabel = Instance.new("TextLabel")
			oreLabel.Size = UDim2.new(1, -10, 0, 15)
			oreLabel.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
			oreLabel.BorderSizePixel = 0
			oreLabel.Text = "  " .. oreName
			oreLabel.TextColor3 = Color3.fromRGB(255, 200, 200)
			oreLabel.TextSize = 7
			oreLabel.Font = Enum.Font.Code
			oreLabel.TextXAlignment = Enum.TextXAlignment.Left
			oreLabel.Parent = leftScroll

			local corner = Instance.new("UICorner")
			corner.CornerRadius = UDim.new(0, 3)
			corner.Parent = oreLabel
		end
	end

	-- Create right items
	if #rightItems == 0 then
		local emptyLabel = Instance.new("TextLabel")
		emptyLabel.Size = UDim2.new(1, 0, 0, 15)
		emptyLabel.BackgroundTransparency = 1
		emptyLabel.Text = "(None)"
		emptyLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
		emptyLabel.TextSize = 7
		emptyLabel.Font = Enum.Font.Code
		emptyLabel.Parent = rightScroll
	else
		for _, oreName in ipairs(rightItems) do
			local oreLabel = Instance.new("TextLabel")
			oreLabel.Size = UDim2.new(1, -10, 0, 15)
			oreLabel.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
			oreLabel.BorderSizePixel = 0
			oreLabel.Text = "  " .. oreName
			oreLabel.TextColor3 = Color3.fromRGB(200, 200, 255)
			oreLabel.TextSize = 7
			oreLabel.Font = Enum.Font.Code
			oreLabel.TextXAlignment = Enum.TextXAlignment.Left
			oreLabel.Parent = rightScroll

			local corner = Instance.new("UICorner")
			corner.CornerRadius = UDim.new(0, 3)
			corner.Parent = oreLabel
		end
	end

	-- Update canvas sizes
	leftScroll.CanvasSize = UDim2.new(0, 0, 0, leftLayout.AbsoluteContentSize.Y + 10)
	rightScroll.CanvasSize = UDim2.new(0, 0, 0, rightLayout.AbsoluteContentSize.Y + 10)

	-- No straight items display anymore - removed!

	print("=== SCREEN UPDATE (TWO COLUMN) ===")
	print("Left items:", #leftItems, "| Right items:", #rightItems)
end

-- Update display when config changes
SORT_CONFIG.ChildAdded:Connect(updateDisplay)
SORT_CONFIG.ChildRemoved:Connect(updateDisplay)
for _, config in pairs(SORT_CONFIG:GetChildren()) do
	if config:IsA("StringValue") then
		config.Changed:Connect(updateDisplay)
	end
end

-- Initial update
updateDisplay()

print("Sorter logic loaded!")
