local RepStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local ITEM_INFO = require(script.Parent.ItemStats)
local PLOT = script.Parent.Parent.Parent.Parent

local SORTER = script.Parent
local SORT_DETECTOR = SORTER:WaitForChild("SortDetector")

-- Storage for sort configuration (player configurable)
if not SORTER:FindFirstChild("SortConfig") then
	local config = Instance.new("Folder")
	config.Name = "SortConfig"
	config.Parent = SORTER
end

local SORT_CONFIG = SORTER.SortConfig

-- Detection settings
local DETECTION_HEIGHT = 3
local trackedOres = {} -- Track ores and their assigned directions

-- Helper to get ore info
local function getOreInfo(part)
	local ore = nil
	local oreModelName = nil

	-- Check if part itself is ore
	if part:FindFirstChild("Cash") and part:FindFirstChild("OreModelName") then
		ore = part
		oreModelName = part.OreModelName.Value
		-- Check if parent model is ore
	elseif part.Parent and part.Parent:IsA("Model") and part.Parent:FindFirstChild("Cash") and part.Parent:FindFirstChild("OreModelName") then
		ore = part.Parent:FindFirstChildWhichIsA("BasePart")
		oreModelName = part.Parent.OreModelName.Value
	end

	return ore, oreModelName
end

-- Get sort direction for an ore type
local function getSortDirection(oreModelName)
	local config = SORT_CONFIG:FindFirstChild(oreModelName)
	if config and config:IsA("StringValue") then
		return config.Value -- "Left", "Right", or "Straight"
	end
	return "Straight" -- Default: straight through
end

-- Calculate sort velocity
local function getSortVelocity(direction)
	local baseCFrame = SORT_DETECTOR.CFrame
	local speed = ITEM_INFO.SortSpeed

	if direction == "Left" then
		-- Rotate left by SortAngle degrees
		local angle = math.rad(ITEM_INFO.SortAngle)
		return (baseCFrame * CFrame.Angles(0, angle, 0)).LookVector * speed
	elseif direction == "Right" then
		-- Rotate right by SortAngle degrees
		local angle = math.rad(-ITEM_INFO.SortAngle)
		return (baseCFrame * CFrame.Angles(0, angle, 0)).LookVector * speed
	else -- "Straight"
		return baseCFrame.LookVector * speed
	end
end

-- Check if ore is within sorter bounds
local function isOreOnSorter(orePart)
	local localPos = SORT_DETECTOR.CFrame:PointToObjectSpace(orePart.Position)
	local halfSize = SORT_DETECTOR.Size / 2

	local marginX = 0.5
	local marginY = 2.5
	local marginZ = 0.5

	local withinX = math.abs(localPos.X) <= (halfSize.X + marginX)
	local withinY = math.abs(localPos.Y) <= (halfSize.Y + marginY)
	local withinZ = math.abs(localPos.Z) <= (halfSize.Z + marginZ)

	return withinX and withinY and withinZ
end

-- Track ores entering the sorter
SORT_DETECTOR.Touched:Connect(function(hit)
	local ore, oreModelName = getOreInfo(hit)

	if ore and oreModelName and not trackedOres[ore] then
		local direction = getSortDirection(oreModelName)

		trackedOres[ore] = {
			direction = direction,
			startTime = tick(),
			startPosition = ore.Position,
			showedMessage = false
		}

		print("Ore entered sorter:", oreModelName, "->", direction)
	end
end)

-- Continuously move ores through the sorter
RunService.Heartbeat:Connect(function()
	-- Get all parts in detection region
	local detectionSize = Vector3.new(
		SORT_DETECTOR.Size.X,
		DETECTION_HEIGHT,
		SORT_DETECTOR.Size.Z
	)

	local detectionCFrame = SORT_DETECTOR.CFrame * CFrame.new(0, DETECTION_HEIGHT/2, 0)
	local partsInRegion = workspace:GetPartBoundsInBox(detectionCFrame, detectionSize)

	-- Update tracked ores
	for ore, data in pairs(trackedOres) do
		-- Clean up if ore destroyed
		if not ore.Parent then
			trackedOres[ore] = nil
			-- Clean up if traveled too far or too much time
		elseif (ore.Position - data.startPosition).Magnitude > SORT_DETECTOR.Size.Z * 3 or (tick() - data.startTime) > 5 then
			trackedOres[ore] = nil
			-- Keep moving if still on sorter
		elseif isOreOnSorter(ore) then
			local velocity = getSortVelocity(data.direction)
			ore.AssemblyLinearVelocity = velocity

			-- Show visual feedback once
			if not data.showedMessage then
				data.showedMessage = true

				local plotOwner = game.Players:FindFirstChild(PLOT.Owner.Value)
				if plotOwner then
					RepStorage.Events.MessageClient:FireClient(
						plotOwner,
						"visual",
						{
							["visual_part"] = SORT_DETECTOR,
							["message"] = data.direction == "Straight" and "‚Üë" or (data.direction == "Left" and "‚Üê" or "‚Üí"),
							["message_color"] = data.direction == "Straight" and Color3.fromRGB(200, 200, 200) or (data.direction == "Left" and Color3.fromRGB(255, 150, 150) or Color3.fromRGB(150, 150, 255)),
							["message_time"] = 0.5
						}
					)
				end
			end
		else
			-- Ore left the sorter
			trackedOres[ore] = nil
		end
	end

	-- Check for new ores in region
	for _, part in pairs(partsInRegion) do
		local ore, oreModelName = getOreInfo(part)

		if ore and oreModelName and not trackedOres[ore] and isOreOnSorter(ore) then
			local direction = getSortDirection(oreModelName)

			trackedOres[ore] = {
				direction = direction,
				startTime = tick(),
				startPosition = ore.Position,
				showedMessage = false
			}
		end
	end
end)

-- Display current configuration on BillboardGui
local function updateDisplay()
	local displayGui = SORTER:FindFirstChild("DisplayGui")
	if not displayGui then return end

	local textLabel = displayGui:FindFirstChild("TextLabel")
	if not textLabel then
		-- Create TextLabel if it doesn't exist
		textLabel = Instance.new("TextLabel")
		textLabel.Size = UDim2.new(1, 0, 1, 0)
		textLabel.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
		textLabel.BackgroundTransparency = 0.3
		textLabel.BorderSizePixel = 0
		textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
		textLabel.TextSize = 24 -- Fixed size instead of TextScaled
		textLabel.TextWrapped = true
		textLabel.Font = Enum.Font.GothamBold
		textLabel.TextXAlignment = Enum.TextXAlignment.Left
		textLabel.TextYAlignment = Enum.TextYAlignment.Top
		textLabel.Parent = displayGui

		-- Add padding
		local padding = Instance.new("UIPadding")
		padding.PaddingTop = UDim.new(0, 10)
		padding.PaddingBottom = UDim.new(0, 10)
		padding.PaddingLeft = UDim.new(0, 15)
		padding.PaddingRight = UDim.new(0, 15)
		padding.Parent = textLabel

		-- Add corner
		local corner = Instance.new("UICorner")
		corner.CornerRadius = UDim.new(0, 8)
		corner.Parent = textLabel
	end

	-- Build display text
	local displayLines = {"üì¶ Sorter Config:"}
	local hasConfig = false
	local configCount = 0

	-- Collect all configs into a sorted table
	local configs = {}
	for _, config in pairs(SORT_CONFIG:GetChildren()) do
		if config:IsA("StringValue") then
			table.insert(configs, {name = config.Name, value = config.Value})
		end
	end

	-- Sort alphabetically
	table.sort(configs, function(a, b)
		return a.name < b.name
	end)

	-- Build display lines
	for _, config in ipairs(configs) do
		hasConfig = true
		configCount = configCount + 1

		local oreName = config.name:gsub("OreModel", ""):gsub("_", " ")
		local arrow = config.value == "Left" and "‚Üê" or (config.value == "Right" and "‚Üí" or "‚Üë")
		table.insert(displayLines, oreName .. " " .. arrow)

		-- Limit to 6 items to prevent overflow
		if configCount >= 6 then
			table.insert(displayLines, "...")
			break
		end
	end

	if not hasConfig then
		displayLines = {"üì¶ Sorter", "", "(Not Configured)", "", "Press E to config"}
	end

	-- Join with newlines
	textLabel.Text = table.concat(displayLines, "\n")

	print("=== DISPLAY UPDATE ===")
	print(textLabel.Text)
	print("===================")
end

-- Update display when config changes
SORT_CONFIG.ChildAdded:Connect(updateDisplay)
SORT_CONFIG.ChildRemoved:Connect(updateDisplay)
for _, config in pairs(SORT_CONFIG:GetChildren()) do
	if config:IsA("StringValue") then
		config.Changed:Connect(updateDisplay)
	end
end

-- Initial update
updateDisplay()

print("Sorter logic loaded!")
