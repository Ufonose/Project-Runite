local RepStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local ITEM_INFO = require(script.Parent.ItemStats)
local PLOT = script.Parent.Parent.Parent.Parent

local SORTER = script.Parent
local SORT_DETECTOR = SORTER:WaitForChild("SortDetector")

-- Storage for sort configuration (player configurable)
if not SORTER:FindFirstChild("SortConfig") then
	local config = Instance.new("Folder")
	config.Name = "SortConfig"
	config.Parent = SORTER
end

local SORT_CONFIG = SORTER.SortConfig

-- Detection settings
local DETECTION_HEIGHT = 3
local trackedOres = {} -- Track ores and their assigned directions

-- Helper to get ore info
local function getOreInfo(part)
	local ore = nil
	local oreModelName = nil

	-- Check if part itself is ore
	if part:FindFirstChild("Cash") and part:FindFirstChild("OreModelName") then
		ore = part
		oreModelName = part.OreModelName.Value
		-- Check if parent model is ore
	elseif part.Parent and part.Parent:IsA("Model") and part.Parent:FindFirstChild("Cash") and part.Parent:FindFirstChild("OreModelName") then
		ore = part.Parent:FindFirstChildWhichIsA("BasePart")
		oreModelName = part.Parent.OreModelName.Value
	end

	return ore, oreModelName
end

-- Get sort direction for an ore type
local function getSortDirection(oreModelName)
	local config = SORT_CONFIG:FindFirstChild(oreModelName)
	if config and config:IsA("StringValue") then
		return config.Value -- "Left", "Right", or "Straight"
	end
	return "Straight" -- Default: straight through
end

-- Calculate sort velocity
local function getSortVelocity(direction)
	local baseCFrame = SORT_DETECTOR.CFrame
	local speed = ITEM_INFO.SortSpeed

	if direction == "Left" then
		-- Rotate left by SortAngle degrees
		local angle = math.rad(ITEM_INFO.SortAngle)
		return (baseCFrame * CFrame.Angles(0, angle, 0)).LookVector * speed
	elseif direction == "Right" then
		-- Rotate right by SortAngle degrees
		local angle = math.rad(-ITEM_INFO.SortAngle)
		return (baseCFrame * CFrame.Angles(0, angle, 0)).LookVector * speed
	else -- "Straight"
		return baseCFrame.LookVector * speed
	end
end

-- Check if ore is within sorter bounds
local function isOreOnSorter(orePart)
	local localPos = SORT_DETECTOR.CFrame:PointToObjectSpace(orePart.Position)
	local halfSize = SORT_DETECTOR.Size / 2

	local marginX = 0.5
	local marginY = 2.5
	local marginZ = 0.5

	local withinX = math.abs(localPos.X) <= (halfSize.X + marginX)
	local withinY = math.abs(localPos.Y) <= (halfSize.Y + marginY)
	local withinZ = math.abs(localPos.Z) <= (halfSize.Z + marginZ)

	return withinX and withinY and withinZ
end

-- Track ores entering the sorter
SORT_DETECTOR.Touched:Connect(function(hit)
	local ore, oreModelName = getOreInfo(hit)

	if ore and oreModelName and not trackedOres[ore] then
		local direction = getSortDirection(oreModelName)

		trackedOres[ore] = {
			direction = direction,
			startTime = tick(),
			startPosition = ore.Position,
			showedMessage = false
		}

		print("Ore entered sorter:", oreModelName, "->", direction)
	end
end)

-- Continuously move ores through the sorter
RunService.Heartbeat:Connect(function()
	-- Get all parts in detection region
	local detectionSize = Vector3.new(
		SORT_DETECTOR.Size.X,
		DETECTION_HEIGHT,
		SORT_DETECTOR.Size.Z
	)

	local detectionCFrame = SORT_DETECTOR.CFrame * CFrame.new(0, DETECTION_HEIGHT/2, 0)
	local partsInRegion = workspace:GetPartBoundsInBox(detectionCFrame, detectionSize)

	-- Update tracked ores
	for ore, data in pairs(trackedOres) do
		-- Clean up if ore destroyed
		if not ore.Parent then
			trackedOres[ore] = nil
			-- Clean up if traveled too far or too much time
		elseif (ore.Position - data.startPosition).Magnitude > SORT_DETECTOR.Size.Z * 3 or (tick() - data.startTime) > 5 then
			trackedOres[ore] = nil
			-- Keep moving if still on sorter
		elseif isOreOnSorter(ore) then
			local velocity = getSortVelocity(data.direction)
			ore.AssemblyLinearVelocity = velocity

			-- Show visual feedback once
			if not data.showedMessage then
				data.showedMessage = true

				local plotOwner = game.Players:FindFirstChild(PLOT.Owner.Value)
				if plotOwner then
					RepStorage.Events.MessageClient:FireClient(
						plotOwner,
						"visual",
						{
							["visual_part"] = SORT_DETECTOR,
							["message"] = data.direction == "Straight" and "↑" or (data.direction == "Left" and "←" or "→"),
							["message_color"] = data.direction == "Straight" and Color3.fromRGB(200, 200, 200) or (data.direction == "Left" and Color3.fromRGB(255, 150, 150) or Color3.fromRGB(150, 150, 255)),
							["message_time"] = 0.5
						}
					)
				end
			end
		else
			-- Ore left the sorter
			trackedOres[ore] = nil
		end
	end

	-- Check for new ores in region
	for _, part in pairs(partsInRegion) do
		local ore, oreModelName = getOreInfo(part)

		if ore and oreModelName and not trackedOres[ore] and isOreOnSorter(ore) then
			local direction = getSortDirection(oreModelName)

			trackedOres[ore] = {
				direction = direction,
				startTime = tick(),
				startPosition = ore.Position,
				showedMessage = false
			}
		end
	end
end)

print("Sorter logic loaded!")